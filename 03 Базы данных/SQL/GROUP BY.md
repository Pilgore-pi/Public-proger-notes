#Syntax/SQL/Group_by

Этот оператор позволяет получить сводную инфу о каждой строке таблицы SQL. Можно сказать, что вводится локальный идентификатор — группируемое поле. Для каждого неповторяющегося значения поля рассчитывается сумма или выполняется другая агрегатная операция между последовательно идущими двумя элементами.

## Агрегатная операция

Допустим у нас есть массив полей чисел:

| 1   | 2   | 1   | 6   | 3   |
| --- | --- | --- | --- | --- |

Сумма всех элементов: $1 + 2 + 1 + 6 + 3 = 15$. Выполнилось 4 агрегатные операции сложения над двумя операндами (параметрами операции сложения)

Теперь пример с таблицей "`Бизнесмены`":

| Продавец | Товар                  |
| -------- | ---------------------- |
| Илюша    | игрушка человека-паука |
| Савва    | игрушка человека-паука |
| Андрюша  | водяной пистолет       |
| Савва    | ледянка                |
| Илюша    | плюшевый Хаги-Ваги     |
| Илюша    | резиновая ящерица      |

Можно выделить 3 группы по полю `Продавец`

1. Илюша
2. Савва
3. Андрюша

Для каждой группы определено несколько товаров. Например, у Илюши 3 игрушки. По этой причине нельзя в запросе `select` выбирать поля, не входящие в группировку, нельзя выбрать поле `Продавец` и все товары этого продавца, иначе получится, что выборка будет вложенной или древовидной. SQL не поддерживает такие структуры.

```sql
SELECT Продавец, COUNT(Товар) FROM 
```

```sql
SELECT [литералы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
GROUP BY поля_группировки;
```

>Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, т.е. при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу


### Группировка по нескольким полям

Допустим у нас есть таблица `Столяр` со свойствами: Имя, Изделие, Деталь.

* Одному имени соответствует множество изделий
* Одному изделию соответствует множество деталей

| Имя   | Изделие              | Деталь          |
| ----- | -------------------- | --------------- |
| Гриша | Киянка               | Рукоять         |
| Гриша | Киянка               | Брусок          |
| Гриша | Деревянный танк КВ-2 | Башня           |
| Гриша | Деревянный танк КВ-2 | Корпус          |
| Гриша | Деревянный танк КВ-2 | Пушка           |
| Олежа | Линейка              | Фонера          |
| Олежа | Салфетница           | Основание       |
| Олежа | Салфетница           | Вырезная деталь |

Сделаем две группировки: сначала по Именам, затем по Изделиям:

Группировка по именам:

```sql
select имя, count(изделие) as КоличествоИзделий from Столяр
group by имя
```

Результат:

| Имя   | Количество изделий |
| ----- | ------------------ |
| Гриша | 5                  |
| Олежа | 3                  |

Теперь дополнительно сгруппируем первоначальную таблицу `Столяр` по полю `Изделие`

```sql
select имя, изделие, count(деталь) as КоличествоДеталей from Столяр
group by имя, изделие
```

Результат:

| Имя   | Изделие              | Количество деталей |
| ----- | -------------------- | ------------------ |
| Гриша | Киянка               | 2                  |
| Гриша | Деревянный танк КВ-2 | 3                  |
| Олежа | Линейка              | 1                  |
| Олежа | Салфетница           | 2                  |

В примерах были использованы ненормализованные таблицы для простоты восприятия.

>В группировке можно выбирать только группируемые поля и агрегатные функции над остальными полями.

Существующие агрегатные функции:

| Агрегатная функция | Описание                        |
| ------------------ | ------------------------------- |
| `COUNT()`          | Подсчитывает количество полей   |
| `SUM()`            | Находит сумму числовых полей    |
| `MIN()`            | Находим минимальное значение\*  |
| `MAX()`            | Находит максимальное значение\* |
| `AVERAGE()`        | Находит среднее значение        |


#DB #SQL
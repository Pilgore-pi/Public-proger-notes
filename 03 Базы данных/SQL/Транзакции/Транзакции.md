>Транзакции — последовательности логически связанных SQL-запросов, рассматриваемых как одно целое.

Если все команды выполнены успешно, транзакция завершается, в противном случае она откатывается назад.

Транзакции в основном применяются для обработки одновременного доступа к данным базы.

Существует 3 вида транзакций:
1. Транзакции с автофиксацией (по умолчанию в MS SQL)
2. Неявные — любые отдельные инструкции (SELECT, UPDATE, INSERT)
3. Явные — группа инструкция языка Transact-SQL

## Транзакции с автофиксацией

Любые команды рассматриваются как транзакции, которые отменяются при ошибках, и фиксируются при их отсутствии.

## Неявные транзакции

Можно включить с помощью команды SET IMPLICIT_TRANSACTIONS ON. В данном режиме транзакция начинается автоматически при выполнении первой инструкции (DML, DDL или SELECT). Значение @@trancount будет 1. Все последующие инструкции станут частью этой транзакции, которую нужно вручную завершить с помощью ROLLBACK или COMMIT.
Приемущества:
1) Можно делать откаты

Недостатки:
1) Нужно следить за завершением транзакции, чтобы не возникло ошибок доступа
2) Любые блокировки сохраняются до завершения транзакции. Таким образом можно заблокировать других пользователей.

[продолжение со скушным дядей 17-00](https://www.youtube.com/watch?v=YWkf3AAUJ70)

В СУБД SQLite & PostgreSQL начало и завершение транзакции выглядят так:

```sql
BEGIN;
--Commands
COMMIT;
```

В MSSQL:

```sql
BEGIN TRANSACTION;
--Commands
COMMIT;
```

Допустим, в базе данных SampleDb сотруднику "Василий Фролов" требуется присвоить новый табельный номер. Этот номер нужно одновременно изменить в двух разных таблицах. В частности, требуется одновременно изменить строку в таблице Employee и соответствующие строки в таблице Works_on. Если обновить данные только в одной из этих таблиц, данные базы данных SampleDb будут несогласованны, поскольку значения первичного ключа в таблице Employee и соответствующие значения внешнего ключа в таблице Works_on не будут совпадать.

```sql
— Начало транзакции
BEGIN TRANSACTION
    UPDATE Employee
        SET Id = 14568
        WHERE Id = 10102
	
    IF (@@error <> 0)
        — Отменить транзакцию, если есть ошибки
        ROLLBACK
	
    UPDATE Works_on
        SET EmpId = 14568
        WHERE EmpId = 10102
	
    IF (@@error <> 0)
        ROLLBACK
— Завершение транзакции
COMMIT
```

Согласованность данных, обрабатываемых в примере, можно обеспечить лишь в том случае, если выполнены обе инструкции UPDATE либо обе не выполнены.
@@error — глобальная переменная, которая при возникновении ошибок принимает отрицательное значение.

## Свойства транзакций

Транзакции должны обладать несколькими важными свойствами, которые имеют общее название [[ACID]].

## Синтаксис
### Начало транзакции

```sql
BEGIN TRANSACTION [Transaction_name | @trans_var [WITH MARK ['Desctiption']]]
— | — один из вариантов
```

* Transaction_name — имя транзакции, которое можно использовать только в самой внешней паре вложенных инструкций BEGIN TRANSACTION/COMMIT или BEGIN TRANSACTION/ROLLBACK.
* В параметре @trans_var указывается имя определяемой пользователем переменной, содержащей действительное имя транзакции.
* Параметр WITH MARK указывает, что транзакция должна быть отмечена в журнале. Аргумент description - это строка, описывающая эту отметку

Инструкция **BEGIN DISTRIBUTED TRANSACTION** запускает распределенную транзакцию, которая управляется Microsoft Distributed Transaction Coordinator (MS DTC - координатором распределенных транзакций Microsoft)

>Распределенная транзакция — это транзакция, которая используется на нескольких базах данных или на нескольких серверах.

### Завершение транзакции

```sql
COMMIT [WORK] — завершает транзакцию
— ИЛИ
COMMIT TRANSACTION
```

### Отмена транзакции

```sql
ROLLBACK [WORK] — отменяет транзакцию
— ИЛИ
ROLLBACK TRANSACTION
```

### Точка сохранения

Точка сохранения — это метка для команды ROLLBACK, позволяющая отменять все команды после заданной точки, не отменяя всю транзакцию.

На следующем примере выполнится лишь первый запрос:

```sql
BEGIN TRANSACTION;
    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d4', 'Скидки');
    SAVE TRANSACTION a;
	
    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d5', 'Исследование');
    SAVE TRANSACTION b;
	
    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d6', 'Менеджмент');
    
    ROLLBACK TRANSACTION b;
	
    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d7', 'Поддержка');
	
    ROLLBACK TRANSACTION a;

COMMIT TRANSACTION;
```

Для третьей инструкции INSERT выполняется откат с помощью инструкции ROLLBACK TRANSACTION b, а для двух других инструкций INSERT будет выполнен откат инструкцией ROLLBACK TRANSACTION a.

>Транзакции могут быть вложены друг в друга.

Общее количество транзакций хранится в глобальной переменной @@trancount (@@TRANCOUNT).
Значение 0 — нет транзакций
Значение > 0 — есть активные транзакции, при этом значение > 1 указывает на уровень вложенности транзакций

Функция XACT_STATE(my_tran) возвращает состояние транзакции
Значение 0 — транзакция неактивна
Значение 1 — транзакция незафиксирована и может быть зафиксирована
Значение -1 — транзакция незафиксирована и не может быть зафиксирована из-зи ошибки

[Ещё](https://professorweb.ru/my/sql-server/2012/level3/3_14.php)

#DB #SQL #SQL/Transact-SQL
[Объект нельзя использовать в данных формы](https://forum.infostart.ru/forum9/topic275778/)

https://infostart.ru/1c/articles/75329/

https://infostart.ru/1c/articles/198766/

----

Платформа предпринимает массу усилий, чтобы в повседневной работе программиста ему не приходилось с этим заморачиваться. Как правило, мы, как и раньше, присваиваем свойства реквизитам формы, а они попадают в СправочникОбъект, а оттуда – в ИБ.

Разница заключается в том, что теперь на клиенте не существует «СправочникОбъект». Как я уже говорил, это сложный объект, он не сериализуется, а значит, его нельзя передавать с клиента на сервер. Вместо «Объекта» на клиенте существует его упрощенный аналог – хранилище данных – объект ДанныеФормы.

Это, по сути, просто структура, у которой свойства совпадают со свойством объекта


Основным «двигателем» всех аспектов управляемой формы является то, что у нас state-less сервер. На нем не сохраняется ничего, никаких промежуточных данных. Всё состояние формы (текст в полях ввода, строки табличных частей и т.п.) хранится на клиенте. Вся совокупность данных формы называется контекстом формы.


Весь клиент-серверный обмен выполняется через сериализацию данных, а это, в свою очередь накладывает ограничения на те типы данных, которые можно передавать на сервер и обратно. Ограничения существуют из-за того, что не все типы данных поддерживают сериализацию 

## Жизненный цикл формы объекта

Давайте рассмотрим, что происходит, когда мы открываем форму существующего элемента справочника.

1. На клиенте вызывается метод «ОткрытьФорму» или мы просто открываем форму из какого-либо списка справочника. Начинается серверный вызов
2. В памяти сервера создается новый СправочникОбъект, выполняется код модуля объекта (тот, что написан в самом низу модуля)
3. Данные объекта считываются из базы данных, присваиваются значения реквизитов, наполняются табличные части объекта СправочникОбъект.
4. В памяти сервера создается новая управляемая форма элемента
5. Вызывается событие формы ПриЧтенииНаСервере, куда передается свежесозданный СправочникОбъект в параметре ТекущийОбъект
6. Основной реквизит формы «Объект», тот, что в списке реквизитов выделен жирным шрифтом наполняется данными на основании данных СправочникОбъект. Здесь происходит обычное поэлементное присваивание свойствам объекта ДанныеФормы значений, записанных в одноименных свойствах объекта СправочникОбъект. По сути, происходит «ЗаполнитьЗначенияСвойств(ДанныеФормы, СправочникОбъект)
7. СправочникОбъект **уничтожается**. Все его данные стираются из памяти сервера.
8. Вызывается событие формы «ПриСозданииНаСервере», в котором мы получаем уже заполненные ДанныеФормы
9. Данные формы сериализуются и отправляются на клиента, где форма отображается пользователю

Обратите внимание, что СправочникОбъект, к которому мы так привыкли в обычном приложении, уничтожился. Если в модуле объекта были какие-либо глобальные переменные, экспортные или не экспортные, все они стали потеряны.

Сохранить что-либо в данных объекта больше нельзя, все сохранение состояния должно выполняться в ДанныхФормы.

Теперь, давайте рассмотрим процесс записи данных справочника:

1. Пользователь нажимает кнопку «Записать»
2. Выполняется обработчик формы «ПередЗаписью» (на клиенте)
3. Происходит серверный вызов
4. В памяти сервера создается новый СправочникОбъект, он наполняется данными на основании данных текущей формы (что-то вроде ЗаполнитьЗначенияСвойств, но в обратном направлении – пишется из формы в объект)
5. Вызывается обработчик события формы «ПередЗаписьюНаСервере», куда передается свежесозданный СправочникОбъект. С этого момента, если мы хотим что-то записать в базу данных, то менять нужно именно СправочникОбъект. Изменения данных формы не отразятся в записываемом объекте.
6. Вызывается обработчик «ПередЗаписью» самого СправочникОбъект (в модуле объекта)
7. Вызывается обработчик «ПриЗаписи» самого СправочникОбъект (в модуле объекта)
8. Вызывается обработчик события формы «ПриЗаписиНаСервере», транзакция записи еще не завершена и можно отменить запись
9. Вызывается обработчик события формы «ПослеЗаписиНаСервере», транзакция записи уже завершена
10. СправочникОбъект уничтожается
11. Выполняется возврат на клиента, где вызывается обработчик события формы «ПослеЗаписи»

Обратите внимание, серверное состояние восстанавливается с нуля, каждый раз создается новый СправочникОбъект. В промежутках между вызовами сервера он не сохраняется.

----

В управляемых формах на первый план выходит разделение контекста на клиентский и серверный. Для возможности работы по тонким каналам связи вся работа прикладных объектов теперь выполняется только на сервере. На клиенте отображается уже подготовленная на сервере форма, выполняется ввод данных и вызовы сервера для записи введенных данных и других необходимых действий

В модуле управляемой формы возможно объявление переменных, процедур и функций. Так как управляемая форма существует одновременно и на сервере и на клиенте, то каждая процедура и функция  и объявление переменной должны предваряться  директивой компиляции, определяющей среду исполнения.

**Допустимы следующие директивы:**

> `&НаКлиенте` — означает, что метод выполняется на стороне клиента, а **переменная существует все время жизни клиентской части** формы. Клиентская процедура исполняется в среде клиентского приложения.

Доступны: Свойства и методы глобального контекста, доступные на клиенте; экспортные переменные; процедуры и функции модуля управляемого приложения, общих модулей скомпилированных на клиенте, общих модулей скомпилированных на сервере, если у них установлено свойство «Вызов Сервера»; свойства и методы расширения формы, определяемого основным реквизитом; свойства и методы объекта встроенного языка УправляемаяФорма; реквизиты формы; локальный контекст модуля.

> `&НаСервере` — означает, что метод выполняется на стороне сервера, а **переменная существует только во время выполнения серверного вызова**, **при каждом серверном вызове значение переменной сбрасывается**.

Для серверных методов допустимы вызовы:

- серверных,
- серверных внеконтекстных
- и клиент-серверных внеконтекстных методов.

Контекст так же образуется:

- cвойствами,
- методами глобального контекста,
- экспортными процедурами,
- функциями общих модулей скомпилированных на сервере,
- свойствами и методами расширения формы, определяемого основным реквизитом,
- свойствами  и методами объекта встроенного языка `УправляемаяФорма`,
- реквизитами формы.

Клиентские процедуры, функции и переменные недоступны.

> `&НаСервереБезКонтекста` — определяет серверную процедуру, исполняемую вне контекста формы. **Переменные не могут предваряться такой директивой**.

Серверная процедура, исполняемая вне контекста формы, (внеконтекстная) исполняется в среде серверного приложения. В такой процедуре не доступен контекст формы (включая данные формы). Допустимыми являются вызовы только других внеконтекстных процедур. При вызове этих процедур не выполняется передача данных формы на сервер и обратно. Применение внеконтекстных процедур позволяет существенно уменьшить объем передаваемых данных при вызове серверной процедуры из среды клиентского приложения.

> `&НаКлиентеНаСервереБезКонтекста` — используется, когда к процедуре необходимо обращаться как с клиента, так и с сервера. Означает, что метод исполняется как на клиенте, так и на сервере вне контекста формы. **Переменные не могут предваряться такой директивой**.

Таким образом, разработчик должен понимать, что он фактически работает с двумя контекстами исполнения: серверным и клиентским, и между ними происходит обмен данными

При этом нужно учитывать, что на клиенте поддерживается лишь ограниченный набор типов данных и  интерфейсные функции.

**На клиенте не допускается:**

- непосредственная работа с базой данных,
- работа непосредственно с прикладными объектами,
- использование запросов,
- таблиц значений.

Доступность описана в синтакс-помошнике и ее необходимо проверять.

При разработке необходимо заботиться об оптимизации клиент-серверного взаимодействия:

- Основные вычисления должны выполняться в серверных процедурах;
- Нужно уменьшать количество серверных вызовов, когда из процедур `&НаКлиенте` вызываются процедуры `&НаСервереБезКонтекста` и `&НаСервере`;
- Количество контекстных серверных вызовов нужно минимизировать, лучше использовать процедуры `&НаСервереБезКонтекста` и передавать значения через параметры

Еще одна важная особенность управляемой формы состоит в том, что в ней происходит лишь отображение объекта. Основным ее реквизитом является не сам объект, а данные формы, в которые он преобразуется.

Элементами данных формы могут быть

- `ДанныеФормыСтруктура` (СправочникОбъект, ДокументОбъект...)
- `ДанныеФормыКоллекция` (Табличные части, динамические списки, таблицы значений)
- `ДанныеФормыСтруктураСКоллекцией` (НаборЗаписейРегистра)
- `ДанныеФормыДерево` (ДеревоЗначений)

Поэтому, для управляемой формы напрямую свойства и методы объекта недоступны. Чтобы обратиться из формы к свойствам и методам объекта нужно сначала получить объект.

[!https://infostart.ru/upload/iblock/a78/gfywo%20w%20kwmwdt.jpg]


----

Код в формах разделен на 2 логических пространства: Клиент и Сервер. Каждая переменная или функция относится к клиенту, к серверу или к клиенту и серверу.

Ранее прямого разделения на Сервер и Клиент не было. Ранее существовал только толстый клиент, но с выходом версии 8.2 появился **тонкий клиент**, который уменьшил количество вычисляемых операций на стороне клиента.

Каждая из директив компиляции определяет, где будет выполняться процедура или функция: на клиенте или на сервере, и как будет происходить взаимодействие с контекстом формы. Контекст формы находится на клиенте ~И НА СЕРВЕРЕ*

Доступность вызова методов одних из других определяется этой схемой:

- `&НаКлиенте`
    - `&НаСервере`
        - `&НаКлиентеНаСервере`~
            - `&НаСервереБезКонтекста`
                - `&НаКлиентеНаСервереБезКонтекста`

## Где доступны директивы

| Директива                         | Где доступно                       |
| --------------------------------- | ---------------------------------- |
| `&НаКлиенте`                      | Модули форм, общие модули, команды |
| `&НаСервере`                      | Модули форм, общие модули          |
| `&НаКлиентеНаСервере`             | Модули форм                        |
| `&НаСервереБезКонтекста`          | Модули форм                        |
| `&НаКлиентеНаСервереБезКонтекста` | Модули форм                        |

Из клиента можно вызывать любую функцию, а, например, из `&НаСервереБезКонтекста` можно вызывать только `&НаКлиентеНаСервереБезКонтекста`

>**Серверный вызов** – это передача какой-то информации с клиентской части «1С:Предприятие 8» на серверную часть с целью вернуть обратно некий набор данных. Сервер не может инициировать запрос к клиенту

При совершении серверного вызова можно увидеть обновление счетчика "Текущие вызовы" в левой нижней окна приложения

| Сущность кода с аннотацией              | Доступность | Где доступно |
| --------------------------------------- | ----------- | --------------------------------- |
| `&НаСервере` любая сущность             | Есть        | Данные формы, база данных         |
| `&НаКлиенте` любая сущность             | Есть        | Данные формы                      |
| `&НаКлиентеНаСервере` любая сущность    | Есть        | Данные формы                      |
| `&НаСервереБезКонтекста` любая сущность | Есть        | База данных                       |
| `&НаКлиентеНаСервереБезКонтекста` метод | Есть        | Только параметры метода           |
| Метод `&НаКлиенте`                      | Нет         | переменная модуля `&НаСервере`    |
| Метод `&НаСервере`                      | Нет         | переменная модуля `&НаКлиенте`    |

>В общих модулях доступны только 2 директивы: `&НаКлиенте` и `&НаСервере`. В общих модулях контекст формы отсутствует~~

* В правой колонке под "базой данных" подразумевается вся информация в базе данных, объекты конфигурации и метаданные конфигурации. Клиент может получить данные из БД только через серверные вызовы.

Директива `&НаСервере` **используется по умолчанию** и подразумевает выполнение кода на сервере, при этом на сервер передается весь контекст формы (для общих форм контекст не передается~).

При использовании директивы `&НаСервереБезКонтекста` отправка контекста не совершается, что позволяет совершать меньше операций и занимать меньше памяти. Однако можно передать необходимые данные через параметры серверного метода

Рекомендуется совершать минимальное количество серверных вызовов и избегать их выполнение в цикле. Обычно, можно подготовить данные для отправки одним пакетом, чтобы не плодить много вызовов.

Метод с директивой `&НаКлиентеНаСервереБезКонтекста` полностью аналогичен двум таким же методам с директивами: `&НаКлиенте` и `&НаСервереБезКонтекста`. Метод с такой директивой может взаимодействовать с общими модулями

* Нельзя применять несколько директив к методу и объявлять одинаковые методы с разными директивами

## Конвертация данных формы

Для упрощения жизни существуют простые способы преобразования универсальных объектов «ДанныеФормы….» в привычные прикладные объекты и наоборот.

Так, например, можно получить наполненный данными СправочникОбъект на основании данных формы, если вызвать метод `РеквизитФормыВЗначение(«Объект»)`. При этом произойдет то, что описано выше – будет создан новый СправочникОбъект и наполнен данными из указанного реквизита данных формы.

Обратное преобразование выполняется методом «`ЗначениеВРеквизитФормы`». Если мы произвели какие-то действия с данными СправочникОбъект, например, очистили табличную часть, то мы должны поместить наши изменения обратно в форму, иначе будет что?

Правильно, измененный СправочникОбъект будет уничтожен при возврате на клиент, а данные формы останутся неизменными. Цикл записи объекта будет построен на старых данных формы, а стало быть, изменение табличной части просто пропадет.

Для конвертации прикладных объектов в данные формы и обратно существует набор глобальных методов:

| Метод | Описание |
|-|-|
| `ЗначениеВДанныеФормы(значение, объектФормы)` | преобразует объект прикладного типа в данные формы |
| `ДанныеФормыВЗначение(объектФормы, тип)` | (не рекомендуется) преобразует данные формы в объект прикладного типа. **Нельзя преобразовать в объект типа `ТабличнаяЧасть`**. Эффект данного метода полностью совпадает с метдом `РеквизитФормыВЗначение()`. Данный метод требует обязательное указание типа данных, в то время, как `РеквизитФормыВЗначение()` автоматически выводит тип |
| `КопироватьДанныеФормы(источник, приемник)` | Копирует данные одного объекта формы в другой. Возвращает значение Истина, если копирование произведено, или Ложь, если структура объектов несовместима. Метод доступен `&НаКлиенте` |
| `<УправФорма>.РеквизитФормыВЗначение(имяРеквизита, [тип])` | преобразует реквизит данных формы в объект прикладного типа |
| `<УправФорма>.ЗначениеВРеквизитФормы(значение, имяРеквизитаФормы)` | выполняет преобразование объекта прикладного типа в заданный реквизит формы |

Все эти методы, кроме `КопироватьДанныеФормы`, не доступны на клиенте

Упомянутый параметр `объектФормы` может представлять один из типов формы:

- `ДанныеФормыСтруктура`
- `ДанныеФормыКоллекция`
- `ДанныеФормыСтруктураСКоллекцией`
- `ДанныеФормыДерево`

В целом, только эти типы данных поддерживают преобразования в прикладные объекты (помимо примитивных типов)

При преобразовании данных формы в прикладные объекты и обратно используется кеширование объектов, но при этом выполняется проверка актуальности версии объекта в кеше

При выполнении стандартных действий (открытие формы, выполнение стандартной команды Записать и т. д.) в форме с основным реквизитом преобразование выполняется автоматически

Использование данных методов обычно удобнее, так как они имеют, например, информацию о типе реквизита формы. Кроме того, метод РеквизитФормыВЗначение() выполняет установку соответствия данных формы и объекта, которая используется при формировании сообщений (см. [здесь](https://its.1c.ru/db/v837doc/content/src/%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0/%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0%206.%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D1%8B%D0%B9%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81.htm_?anchor=_ref220330559).

При преобразовании ТаблицыЗначений и ДереваЗначений, требуется чтобы количество всех колонок было не меньше, чем в соответствующих элементах формы (ДанныеФормыКоллекция, ДанныеФормыДерево)

> Колонки реквизитов, не связанные с данными, не участвуют в преобразовании значений между данными формы и объектами информационной базы и обратно. Колонки, отсутствующие в данных объекта, очищаются при преобразовании в данные формы

**Пример:**

```bsl
&НаСервере
Процедура ПересчитатьНаСервере()

    // Преобразует реквизит Объект в прикладной объект
    Документ = РеквизитФормыВЗначение(«Объект»);

    // Выполняет пересчет методом, определенным в модуле объекта
    Документ.Пересчитать();

    // Преобразует прикладной объект обратно в реквизит
    ЗначениеВРеквизитФормы(Документ, «Объект»);

КонецПроцедуры
```

> **`ЗначениеВРеквизитФормы()`** необходимо использовать, если происходит редактирование данных формы на сервере, полученных через `РеквизитФормыВЗначение()`, чтобы оповестить форму о совершенных изменениях.

Если бы мы сразу в этой процедуре изменили что-нибудь на форме, то она бы перерисовалась сама собой. А, так как вызывается метод объекта, который никак не связан с представлением, то надо бы "оповестить" форму о том, что ее изменили.

#question

> **Можно ли выполнять преобразование вложенных данных формы, типа Объект.Товары?**

-----

## Предопределенные значения на клиенте

Значение предопределенных данных `&НаКлиенте` можно получить только через функцию `ПредопределенноеЗначение()`

Метод применим к перечислениям, ссылкам, элементам справочников и др.

```bsl
// Пользовательское перечисление
ЮрФизЛицо = ПредопределенноеЗначение("Перечисление.ЮридическоеФизическоеЛицо.ЮридическоеЛицо");

// Системное перечисление (типСистемногоПеречисления.Значение)
ТипДиаграммы = ПредопределенноеЗначение("ТипДиаграммы.ВогнутаяПоверхность");

// Пустая ссылка на тип "Документ.РасходнаяНакладная". Тип - это предопределенное значение
ПредопределенноеЗначение("Документ.РасходнаяНакладная.ПустаяСсылка");

// Получение предопределенных данных справочника
Элемент = ПредопределенноеЗначение("Справочник.Валюта.Рубль");

// Точка маршрута бизнес процесса
Точка = ПредопределенноеЗначение("БизнесПроцесс.Согласование.ТочкаМаршрута.Одобрение");
```

## Управление открытием формы

Отображение форм на экране в управляемом режиме также претерпело некоторые изменения. Прежде всего, формы получили имена, по которым к ним можно обращаться. Например, форма списка справочника  «Контрагенты» будет называться «Справочник.Контрагенты1.ФормаСписка».

Методика открытия формы теперь такова: форма должна открываться одной строчкой кода и одним вызовом сервера. Эту задачу на себя берет глобальный метод «ОткрытьФорму». В данный метод мы должны передать имя формы (см. выше), параметры формы, владельца и ключ уникальности. Все параметры, кроме имени являются необязательными.

Поскольку открытие формы это интерактивная операция, то осуществляться она может только на клиенте. Однако, создание формы, как мы видели из ее жизненного цикла, происходит на сервере. Возникает резонный вопрос, а как открыть форму одной строчкой кода, если нужно каким-то образом параметризовать ее создание, передать ей что-то, чтобы она знала, как именно ей нужно создаваться?

Для этого и нужны Параметры формы. Это структура, которую можно передать в метод «ОткрытьФорму». Переданные параметры можно проанализировать в серверном коде формы и предпринять какие-то действия на основании переданных параметров.

Простой пример, открытие формы списка с отбором. Для того, чтобы список справочника открылся с отбором по определенному условию нужно открыть форму списка и передать ей параметр с именем «Отбор», значением которого будет структура с полями отбора и значениями отбора.

```bsl
УсловияОтбора = Новый Структура;
УсловияОтбора.Вставить("ТипКонтрагента", "Поставщик");
УсловияОтбора.Вставить("Лояльность", "Надежный");

ПараметрыФормы = Новый Структура ("Отбор", УсловияОтбора);

ОткрытьФорму("Справочник.Контрагенты.ФормаСписка", ПараметрыФормы);
```

Существуют системные параметры, на которые реагирует сама платформа. Упомянутый параметр «Отбор» как раз является системным, если он передан форме списка, то платформа сама установит отбор на список.

Кроме того, параметры можно создавать произвольные, в редакторе формы. Более того, параметры можно передавать даже с теми именами, которые не объявлены в форме, они все равно будут видны в серверном коде формы.

Жизненный цикл параметров
Все параметры, переданные в форму в момент ее открытия видны только в процедуре «ПриСозданииНаСервере». После создания все параметры уничтожаются и более не доступны в форме.

Исключение составляют параметры, которые в редакторе формы объявлены с признаком «Ключевой параметр». Такой параметр будет существовать до тех пор, пока существует сама форма.

```bsl
Процедура ПриСозданииНаСервере(Отказ)

    Если Параметры.ЗапуститьЯдерныйРеакторПриОткрытии Тогда
        УправлениеРеактором.Запустить();
    КонецЕсли;

КонецПроцедуры
```

Ключевые параметры определяют уникальность окна. В обычных формах был такой атрибут «Ключ уникальности». Если запрашивалась форма, то она сначала искалась в уже открытых. Ключ уникальности позволял варьировать условия при которых создавалась новая форма или возвращалась существующая. Ту же самую роль играют ключевые параметры. Если метод «ОткрытьФорму» вызван два раза подряд с одним и тем же значением ключевого параметра, то второй вызов не откроет новое окно, а активирует существующее.


----

Передача контекста формы

Платформа выполняет ряд оптимизаций по передаче контекста. Так, например, между клиентом и сервером передаются только изменения контекста, а не весь контекст целиком. Тем не менее, так происходит не всегда, и часто форма пересылается почти полностью. Кроме того, программист не может явно управлять этим процессом и можно считать, что вызов серверного метода «с контекстом» передает все данные формы, а потом еще и получает их обратно с теми изменениями, которые внесены в данные на сервере.


Переменные уровня модуля формы

В форме могут быть объявлены глобальные переменные, а их доступность отрегулирована все теми же директивами компиляции.

Причем, переменная, которая объявлена НаКлиенте, будет доступна все время жизни формы, а переменная НаСервере будет очищаться каждый раз при возврате с сервера (уничтожении данных серверного вызова).


Временное хранилище

При работе с управляемыми формами быстро становится ясно, что ограничения клиент-серверного взаимодействия очень сильно сужают возможности разработчика. Поэтому, платформа 1С предоставляет хитрый секретный ход под названием «ВременноеХранилище». Эта сущность позволяет сохранить на сервере некоторое состояние между двумя серверными вызовами

Временное хранилище позволяет оставить на сервере некоторые данные, а вместо них получить короткую строку – адрес временного хранилища. Этот адрес можно передать на клиента, там он будет спокойно лежать, а когда понадобятся данные из хранилища, то мы по этому адресу сможем их получить.

Для работы со временным хранилищем используются методы ПоместитьВоВременноеХранилище и ПолучитьИзВременногоХранилища.

С методом «Получить» все просто, он по заданному адресу возвращает значение, которое лежит в хранилище.

С методом «Поместить» несколько сложнее. Дело в том, что помещать можно в 2 разных хранилища – простое и хранилище формы. Хранилище формы живет на сервере столько, сколько живет сама форма. Простое хранилище живет ровно 2 серверных вызова. В синтакс-помощнике об этом написано целых несколько умных строк. Я никогда не понимал, что они означают. Опытным путем было установлено, что срок жизни – 2 серверных вызова.

Первый – мы помещаем что-то в хранилище и возвращаем адрес на клиента.
Клиент делает второй вызов и по этому адресу может получить данные.
В третьем вызове по этому адресу уже ничего не будет. Платформа очистит хранилище
С хранилищем формы ситуация более интересная. Если вторым параметром метода «ПоместитьВоВременноеХранилище» передать идентификатор формы (ЭтаФорма.УникальныйИдентификатор), то данные в хранилище будут привязаны к сроку жизни формы и не будут удалятся ни в первых, ни во вторых, ни во всех прочих вызовах сервера.

Таким образом, временное хранилище, это еще одно место, в котором (помимо реквизитов формы) можно сохранять состояние на сервере. Причем, в хранилище можно хранить даже данные, которые на клиенте недоступны, а стало быть, в реквизитах формы их разместить нельзя.

Особенности временного хранилища

Временное хранилище лучше всего представить себе, как файл на сервере. Технически это не так, но особенности оптимизации могут попить крови. Проще думать о нем, как о файле.

Данные, которые мы помещаем в хранилище, должны быть сериализуемыми. В противном случае, они могут внезапно пропасть из временного хранилища.

Как примерно работает временное хранилище:

- Данные помещаются во временное хранилище
- Управление возвращается на клиента
- Клиент делает повторный серверный вызов
- Менеджер кластера переключает вызов на другую машину из кластера (не ту, что помещала данные в хранилище)
- И вот тут, если данные в хранилище были сериализуемые, то все отлично, мы получим их даже на другой машине кластера.
- Если данные не были сериализуемые (СправочникОбъект, COM-объект, что-то еще), то они просто пропадут, ибо нефиг.

Если не вдаваться в дебри документации, то можно сказать примерно следующее: данные во временном хранилище существуют в пределах двух серверных вызовов, либо, если они помещены в хранилище формы, то в течение жизни формы.

Данные в хранилище могут быть сериализованы в любой момент времени по усмотрению сервера. Если данным пришлось сериализоваться, то обратно их можно получить только если тип этих данных поддерживал сериализацию (большинство типов платформы поддерживает).

Если тип данных, помещенных в хранилище не поддерживал сериализацию, то данные просто уничтожаются.

Данные помещаются в хранилище по ссылке. Это значит, что помещая данные в хранилище и изменяя их вне хранилища мы, фактически, меняем и само хранилище, т.к. в нем лежит только ссылка на данные. Пример:

```bsl
Массив = Новый Массив; Массив.Добавить("Привет");

Адрес = ПоместитьВоВременноеХранилище(Массив);

Массив.Добавить("До свидания");

МассивИзХранилища = ПолучитьИзВременногоХранилища(Адрес);

Сообщить(Массив = МассивИзХранилища);     // Истина
Сообщить(МассивИзХранилища.Количество()); // 2 элемента
```

В приведенном коде массив помещается в хранилище, после чего к нему добавляется еще один элемент. Видим, что в хранилище лежит тот же самый объект и объект получаемый из хранилища тоже изменен.

Тем не менее, если данным пришлось сериализоваться (например, произошло переключение на другой сервер кластера), то ссылки уже будут разными, по понятным причинам.

С одной стороны, логика довольно путанная, с другой стороны, ничего страшного. Главное помнить о подводных камнях и не закладывать логику на какое-то побочное поведение хранилища.

----

#1С #1С/Язык_программирования #1С/Формы

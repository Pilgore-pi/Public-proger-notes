> **Регламентные задания** — это [общие объекты конфигурации](https://v8.1c.ru/platforma/obekty-konfiguracii/). Они являются частью [механизма заданий](https://v8.1c.ru/platforma/mehanizm-zadaniy/) и позволяют автоматически выполнять процедуры на встроенном языке по расписанию

Регламентные задания могут выполняться в заданное время, дату и с заданной периодичностью

Существуют **однократные** и **периодические** задания

>Расписание регламентных заданий можно редактировать как в конфигураторе, так и на клиенте

>При выполнении заданий создается фоновое задание, которое выполняет код

Регламентное задание может выполняться от имени заданного пользователя и имеет возможность перезапуска (например, в случае непредвиденного завершения работы)

Также имеется возможность блокировать запуск регламентных заданий при создании информационной базы на сервере из диалога запуска 1С:Предприятия 8

Фоновые задания в 1С 8.3 – это действия, производимые программой 1С незаметно для работающего в ней. Отслеживают их исполнение только по журналу регистрации. Особенностью такого задания является то, что при его выполнении не блокируется работа пользователя, он может продолжать вносить и редактировать данные, даже если процедура запущена.

Фоновые задания — это посредники между регламентным заданием и выполнением кода

При использовании БСП, список заданий можно увидеть в подсистеме **Администрирование** > Настройки программы > Обслуживание

У Регламентных заданий указывается:

- Наименование;
- Состояние (выполняется или выполнено);
- Дата окончания.

У Фоновых заданий:

- Состояние (выполняется или выполнено);
- Наименование;
- Начало;
- Окончание.?????????????

## Свойства объекта конфигурации "Регламентное задание"

Стандартные:

- Имя
- Синоним
- Комментарий

Специфичные:

- **Имя метода**: путь к процедуре, которая будет выполняться в фоновом задании по заданному расписанию. Процедура должна находиться в общем модуле. Рекомендуется не использовать типовые общие модули, а создать свой. ***Фоновые задания выполняются только на сервере***
- **Наименование**: 
- **Расписание**: инфа о том, с какой и до какой даты действует задание, с каким периодом оно выполняется, в какие дни недели, месяцы, дни и недели месяца. Конкретное время можно настроить в настройках дневного выполнения
- **Использование**: доступно ли задание для использования
- **Предопределенное**: параметр определяет, будет ли регламентное задание запущено сразу, как попадет в базу данных. Запущенное задание будет активировано по расписанию, если оно не имеет признак Предопределенного, то его нужно вручную запустить через БСП или в коде, иначе оно никогда не будет выполняться
- **Количество повторов при аварийном завершении**: сколько раз выполнен перезапуск фонового задания, если оно было выполнено с ошибкой
- **Интервал повтора при аварийном завершении**: с КАКОЙ???(СЕКУНДЫ, ГОДА, НАНОСЕКУНДЫ????) периодичностью будет выполнен перезапуск фонового задания, если оно было выполнено с ошибкой

>Регламентные задания не будут работать, если установлена блокировка регламентных заданий. Блокировка настраивается в специальной утилите администрирования

Для управления регламентными заданиями можно воспользоваться консолью заданий

## Настройка регламентных заданий в файловом режиме работы 1С

В файловом режиме настройка таких заданий несколько труднее. Для такого задания должна быть запущена отдельная сессия программы 1С. Зачастую это решается заведением «технического» пользователя, чей сеанс всегда запущен.

В файловом режиме инициализация регламентного задания происходит при запуске метода `ВыполнитьОбработкуЗаданий()`

Для определенного пользователя можно настроить запуск этого метод, используя другой метод:

`ПодключитьОбработчикОжидания(<ИмяПроцедуры>, <Интервал>, <Однократно>)`

Где:

-  **Имя процедуры** — имя процедуры, подключаемой в качестве обработчика ожидания. Имя экспортируемой процедуры модуля управляемого приложения (модуля обычного приложения) или глобального общего модуля. Процедура должна располагаться на клиенте.
- **Интервал** — период между выполнениями операций в секундах.
- **Однократно** — как выполнять задание, один раз или нет.

----

МЕТОД ОПОВЕСТИТЬ (Глобавльныей контекст)

СИСТЕМА ВЗАИМОДЕЙСТВИЯ
МЕНЕДЖЕР СИСТЕМЫ ВЗАИМОДЕЙСТВИЯ
	ПОЛЬЗОВАТЕЛЬ_СИСТЕМЫ_ВЗАИМОДЕЙСТВИЯ
	ОПОВЕЩЕНИЕ_СИСТЕМЫ_ВЗАИМОДЕЙСТВИЯ
	ПОЛУЧИТЬ_СООБЩЕНИЕ() _СООБЩЕНИЕ_СИСТЕМЫ_ВЗАИМОДЕЙСВТИЯ_
	ОБСУЖДЕНИЕ_СИСТЕМЫ_ВЗАИМОДЕЙСТВИЯ

1. Создать Параметр сеанса, булево.

2. Создать HTTP-сервис, при необходимости в нём изменяем Параметр сеанса в Истина.

3. Создать внеш обработку с необходимым интерфейсом клиента для обратной связи.

4. Создать глобальный обработчик оповещения, проверять Параметр сеанса на Истина, при этом вызывать открытие интерфейса внешней обработки. При открытии Параметр сеанса возвращаем в Ложь.


https://1eska.ru/projects/publications/upravlenie-nashey-firmoy-unf/chaty-v-1s-unf/#h2-0

ОбщегоНазначения.СообщитьПользователю()

ДлительныеОперации.ОтправитьОповещениеКлиенту

```bsl
// ОБЩИЙ МОДУЛЬ (БСП) ДлительныеОперации

Процедура ОтправитьОповещениеКлиенту(
	ВидОповещения,
	ПередаваемоеЗначение,
	ФоновоеЗадание = Неопределено,
	ИдентификаторОсновногоЗадания = Неопределено
) Экспорт
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ЗаписатьСообщенияПользователю = ФоновоеЗадание <> Неопределено И ВидОповещения = "СообщениеПользователю";
	Если ЗаписатьСообщенияПользователю Тогда
		КлючСеансаРодителя = СерверныеОповещения.КлючСеанса();
	Иначе
		КлючСеансаРодителя = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере(Ложь).Получить(
			"КлючСеансаРодителя");
		Если Не ЗначениеЗаполнено(КлючСеансаРодителя) Тогда
			Возврат;
		КонецЕсли;
		ФоновоеЗадание = ПолучитьТекущийСеансИнформационнойБазы().ПолучитьФоновоеЗадание();
		Если ФоновоеЗадание = Неопределено Тогда
			Возврат;
		КонецЕсли;
		ИдентификаторЗаданияМногопоточногоПроцесса =
			СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере(Ложь).Получить(
				"ИдентификаторЗаданияМногопоточногоПроцесса");
		ИдентификаторОсновногоЗадания = ?(ЗначениеЗаполнено(ИдентификаторЗаданияМногопоточногоПроцесса),
			ИдентификаторЗаданияМногопоточногоПроцесса, ИдентификаторОсновногоЗадания(ФоновоеЗадание));
	КонецЕсли;
	
	Если ВидОповещения = "ДлительнаяОперацияЗавершена" Тогда
		Если ЗначениеЗаполнено(ИдентификаторЗаданияМногопоточногоПроцесса) Тогда
			Если ИдентификаторЗаданияМногопоточногоПроцесса <> ИдентификаторОсновногоЗадания(ФоновоеЗадание)
			 Или ПередаваемоеЗначение.Статус = "Ошибка" Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
		Результат = ПередаваемоеЗначение;
	Иначе
		Результат = НовыйРезультатВыполненияОперации();
	КонецЕсли;
	Если ВидОповещения = "СообщениеПользователю" Тогда
		Результат.Сообщения = Новый ФиксированныйМассив(
			ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПередаваемоеЗначение));
	ИначеЕсли ВидОповещения = "Прогресс" Тогда
		Сообщения = ФоновоеЗадание.ПолучитьСообщенияПользователю(Истина);
		Для Каждого Сообщение Из Сообщения Цикл
			// @skip-check query-in-loop - ветка с запросом вызывается только при первом вызове в сеансе
			ОтправитьОповещениеКлиенту("СообщениеПользователю", Сообщение);
		КонецЦикла;
		Результат.Сообщения = Новый ФиксированныйМассив(Новый Массив);
		Результат.Прогресс = ПередаваемоеЗначение;
	ИначеЕсли ВидОповещения = "ДлительнаяОперацияЗавершена" Тогда
		Сообщения = ФоновоеЗадание.ПолучитьСообщенияПользователю(Истина);
		Для Каждого Сообщение Из Сообщения Цикл
			// @skip-check query-in-loop - ветка с запросом вызывается только при первом вызове в сеансе
			ОтправитьОповещениеКлиенту("СообщениеПользователю", Сообщение);
		КонецЦикла;
	КонецЕсли;
	
	ПараметрыОповещения = Новый Структура;
	ПараметрыОповещения.Вставить("ВидОповещения", ВидОповещения);
	ПараметрыОповещения.Вставить("ИдентификаторЗадания", ИдентификаторОсновногоЗадания);
	ПараметрыОповещения.Вставить("Результат", Результат);
	ПараметрыОповещения.Вставить("ВремяОтправки", ТекущаяУниверсальнаяДатаВМиллисекундах());
	
	КлючиСеансов = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(КлючСеансаРодителя);
	Адресаты = Новый Соответствие;
	Адресаты.Вставить(ПользователиИнформационнойБазы.ТекущийПользователь().УникальныйИдентификатор, КлючиСеансов);
	
	ДополнительныеПараметрыОтправки = СерверныеОповещения.ДополнительныеПараметрыОтправки();
	ДополнительныеПараметрыОтправки.ИдентификаторГруппы  = ИдентификаторОсновногоЗадания;
	ДополнительныеПараметрыОтправки.ВидОповещенияВГруппе = ИдентификаторВидаОповещения(ВидОповещения);
	
	Если ВидОповещения = "Прогресс" Тогда
		ДополнительныеПараметрыОтправки.Заменить = Истина;
		ДополнительныеПараметрыОтправки.ОтсрочкаДоставки = 3;
		ДополнительныеПараметрыОтправки.СобытиеЖурналаПриОтсрочкеДоставки =
			НСтр("ru = 'Длительные операции.Отложенная доставка прогресса'",
				ОбщегоНазначения.КодОсновногоЯзыка());
		ДополнительныеПараметрыОтправки.КомментарийЖурналаПриОтсрочкеДоставки =
			НСтр("ru = 'Отправка прогресса чаще одного раза в 3 сек.'");
	КонецЕсли;
	
	СерверныеОповещения.ОтправитьСерверноеОповещениеСИдентификаторомГруппы(ИмяОповещения(),
		ПараметрыОповещения, Адресаты, Не ЗаписатьСообщенияПользователю, ДополнительныеПараметрыОтправки);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры
```

ФоновоеЗадание.ПолучитьСообщенияПользователю()

[Система Взаимодействия](https://infostart.ru/1c/articles/2014266/)
Позволяет передавать информацию с сервера на клиент
В системе взаимодействия все клиенты и сервер являются клиентами системы взаимодействия и могут передавать друг другу сообщения.

На текущий момент сервер системы взаимодействия реализован в двух вариантах.

- Первый вариант – это **бесплатный облачный сервис** от фирмы «1С» 1cdialog.com
    
- Второй вариант – это **дистрибутив для локальной установки**. Он поставляется за рубли.

## М б просто отправлять HTTP-запросы с сервера на клиент? Но как клиент узнает о входящем запросе?


## КАК происходит посылка сообщения пользователю с сервера на клиент через ОбщегоНазначения.СообщитьПользователю()?

>Следует иметь в виду, что сообщения, выведенные командой «Сообщить» или через объект «_СообщениеПользователю_» **всегда привязаны к какой-либо форме**. Если после вывода сообщения форма закрывается, пользователь не сможет его прочитать. Если нужно сделать независимое от формы оповещение, нужно использовать ПоказатьОповещениеПользователю

https://infostart.ru/1c/articles/1004554/

```bsl
ПоказатьОповещениеПользователя(<Текст>,               // ЗАГОЛОВОК оповещения
                               <ДействиеПриНажатии>, 
                               <Пояснение>,           // Текст оповещения
                               <Картинка>, 
                               <СтатусОповещенияПользователя>, 
                               <КлючУникальности>)
```

_ДействиеПриНажатии_ может содержать либо навигационную ссылку, по которой необходимо перейти при нажатии на сообщении, либо описание процедуры оповещения

_Примечание._ _Следует использовать данный метод для информационных, не особенно важных сообщения, так как они исчезают самостоятельно, без каких либо действий со стороны пользователя_


**ПолучитьСообщенияПользователю**

**Эта функция выводит накопленные (поле Сообщение.Сообщить()) и еще не выведенные сообщения.**  
**Она характерна для регламентных или фоновых заданий. В обычном сеансе получить с помощью нее сообщения не получиться, на сколько я знаю. Так как они сразу будут выведены пользователям.**

Если сообщение пользователю вызывается с сервера, а метод, который нужно выполнить, должен выполняться на клиенте, можно использовать механизм обмена данными между сервером и клиентом. В 1С это можно реализовать через вызов клиентских процедур из серверного кода.

## Способы реализации

****1. Использование события на клиенте****

Вы можете использовать событие на клиенте, чтобы отслеживать момент, когда сервер отправляет сообщение. Например, вы можете установить флаг или вызвать метод на клиенте после завершения обработки серверного кода.

### Пример реализации

На сервере:

```1C
Процедура ВывестиСообщениеНаСервере()
    // Ваш код
    Сообщить("Операция завершена успешно!");

    // Уведомляем клиента
    ЭтотОбъект.УстановитьФлагСообщения();
КонецПроцедуры
```

На клиенте:

```1C
Процедура УстановитьФлагСообщения()
    // Выполняем нужный метод
    ВашМетод();
КонецПроцедуры

Процедура ВашМетод()
    Сообщить("Метод выполнен на клиенте!");
КонецПроцедуры
```

***2. Использование механизма "События"***

Если вы хотите более гибкий подход, можно использовать механизм событий. На сервере вы можете вызвать событие, а на клиенте подписаться на него.

### Пример реализации

На сервере:

```1C
Процедура ВывестиСообщениеНаСервере()
    Сообщить("Операция завершена успешно!");

    // Генерируем событие для клиента
    ЭтотОбъект.СообщениеВыведено();
КонецПроцедуры
```

На клиенте:

```1C
&НаКлиенте
Процедура СообщениеВыведено()
    ВашМетод();
КонецПроцедуры

Процедура ВашМетод()
    Сообщить("Метод выполнен на клиенте!");
КонецПроцедуры
```

## Заключение

Таким образом, вы можете использовать либо флаги для уведомления клиента о том, что сообщение было выведено, либо события для более сложных сценариев. Оба подхода позволяют эффективно отслеживать момент вывода сообщения и выполнять нужные действия на клиенте.

#1С #1С/Конфигурация
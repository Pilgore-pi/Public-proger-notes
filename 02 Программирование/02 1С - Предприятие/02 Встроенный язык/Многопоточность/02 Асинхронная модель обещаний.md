
Использование методов обратного вызова усложняет программный код, делает его фрагментированным, сложным для восприятия и доработки. Синхронный код, в котором выполняемые команды расположены последовательно, друг за другом, создается и анализируется гораздо проще.

По этой причине разработчики создали более современную асинхронную модель на основе понятия обещаний. В других языках программирования они называются `promise`, `future`, `task`

Похожий подход был реализован фирмой “1С” в платформе 8.3.18

Важно отметить, что сам принцип использования асинхронности в платформе остался прежним. По-прежнему асинхронность доступна для работы с блокирующими окнами, файлами и каталогами, механизмами криптографии и внешними компонентами. Изменился только “внешний вид” программного кода, другими словами – способ указания платформе, какой именно код нужно выполнить после завершения асинхронного метода. Главная задача нововведения – приблизить асинхронный код к обычному последовательному коду, уменьшить сложность разработки.

## Обещания

В платформе 8.3.18 появился новый тип данных – Обещание. Объект такого типа предназначен для организации асинхронного кода.

>***Обещание*** — это контейнер, который содержит в себе значение некоторого типа. Предполагается, что в будущем `Обещание` вернет результат, но это не гарантировано.

Например, существует обещание: "получить данные из БД". Такое "Обещание" говорит, что после выполнения операции получения данных из БД, мы сможем использовать результат обещания, но пока запрос к БД не выполниться, мы будем ждать результата, параллельно выполняя основную логику программы.

Существует 3 исхода выполнения асинхронной функции:

1. Мы **дождались** выполнения асинхронного метода и получили результат.
2. Мы **ждем** выполнения асинхронного метода и не получили результат, так как метод все еще выполняется. Возможно, асинхронный метод будет выполняться бесконечно.
3. Мы **не дождались** результата, так как асинхронный метод завершился с ошибкой (вернул `Неопределено`).

Как можно понять, нельзя всегда гарантированно получить результат, поэтому был введен тип `Обещание`, который обрабатывает такую логику и допускает все перечисленные состояния.

Оператор `ждать` может быть использован только внутри асинхронного метода. Этот оператор говорит, что нужно остановить выполнение кода и ждать до тех пор, пока `Обещание` не вернет значение. Если не использовать `ждать`, то ожадания не будет и код продолжит свое выполнение.

Асинхронный метод выполняется в фоновом потоке параллельно с основным. В версии 8.3.18 был добавлен специальный синтаксис:

```bsl
Асинх Процедура ИмяПроцедуры(<параметры>) //async
    [ждать] <Обещание>;                   //await
КонецПроцедуры

Асинх Функция ИмяФункции(<параметры>)
    возврат <Значение>;
КонецФункции
```

Фактически **Обещание** является заменой объекта `ОписаниеОповещения`.
При использовании асинхронности с методами обратного вызова в этом объекте указывается, какую процедуру нужно выполнить после завершения асинхронного метода. Результат выполнения асинхронного метода будет содержаться в параметре метода обратного вызова. При использовании асинхронности через обещания результат асинхронной функции будет содержаться именно в объекте типа **Обещание**.

> Объект типа **Обещание** доступен только в клиентском контексте: в тонком, толстом, мобильном клиентах и в веб-клиенте. На сервере этот объект недоступен. Это связано с тем, что асинхронные методы во встроенном языке создавались для использования только на клиенте

Объект Обещание не имеет конструкторов, методов и свойств. Объект такого типа можно получить во встроенном языке только в качестве результата вызова асинхронной функции.
Далее Обещание можно использовать в качестве аргумента оператора Ждать, чтобы получить результат выполнения асинхронной функции

> В новой асинхронной модели также существует конвенция именования асинхронных методов: их имена должны заканчиваться на "Асинх"

```bsl
Вопрос(            // Синхронный вариант
    <ТекстВопроса>,
    <Кнопки>,
    <Таймаут>,
    <КнопкаПоУмолчанию>,
    <Заголовок>,
    <КнопкаТаймаута>
);

ПоказатьВопрос(    // Асинхронный Callback-вариант
    <ОписаниеОповещенияОЗавершении>,
    <ТекстВопроса>,
    <Кнопки>,
    <Таймаут>,
    <КнопкаПоУмолчанию>,
    <Заголовок>,
    <КнопкаТаймаута>
);

ВопросАсинх(       // Асинхронный Promise-вариант
    <ТекстВопроса>,
    <Кнопки>,
    <Таймаут>,
    <КнопкаПоУмолчанию>,
    <Заголовок>,
    <КнопкаТаймаута>
);
```

Синхронный метод и асинхронный метод с обещанием являются функциями, а метод `ПоказатьВопрос()` является процедурой

Не для всех синхронных методов реализованы аналогичные функции с модификатором Асинх. Например, для метода формы ОткрытьМодально соответствующая асинхронная функция не существует. Поэтому следует использовать процедуру ОткрытьФорму с указанием обработчика оповещения:

```bsl
&НаКлиенте
Процедура ВыбратьНоменклатуру(Команда)
    
    ОписаниеОповещения = Новый ОписаниеОповещения(
        "ОткрытиеФормыЗавершение",
        ЭтотОбъект
    );
    
    ОткрытьФорму(
        "Справочник.Номенклатура.ФормаВыбора", , , , , ,
        ОписаниеОповещения,
        РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
    
КонецПроцедуры

&НаКлиенте
Процедура ОткрытиеФормыЗавершение(РезультатЗакрытия, ДополнительныеПараметры) Экспорт
    //Обработка результата...
КонецПроцедуры
```

> В общем случае, асинхронный метод с обратным вызовом нельзя преобразовать в функцию, возвращающую обещание (Promise), так как встроенный язык не предоставляет таких возможностей

### Оператор `ждать`

Оператор ждать применяется только к объекту типа **Обещание** и возвращает результат этого обещания.

Можно сказать, что `ждать` открывает контейнер "Обещание" и достает оттуда результат, если он есть

```bsl
Результат = Ждать Обещание;
```

> Если в асинхронном методе возникло исключение и оно не было обработано, то исключение перейдет на уровень выше, где выполняется оператор "ждать"

Если операндом оператора `ждать` будет не Обещание, то операнд будет упакован в обещание, результатом которого будет этот операнд:

```bsl
результат = Ждать 1000; // Task.Run(() => 1000)
Сообщить(результат);    // 1000
```

### Модификатор `Асинх`

Имена асинхронных функций платформы, возвращающих Обещание, заканчиваются на Асинх. Если разработчику нужно реализовать собственную процедуру или функцию, которая будет работать асинхронно, ее нужно описать с использованием модификатора Асинх:

```bsl
&НаКлиенте
Асинх Процедура ИмяПроцедуры()
    
КонецПроцедуры

&НаКлиенте
Асинх Функция ИмяФункции()
    
КонецФункции
```

Некоторые особенности асинхронных методов

- Только внутри процедур или функций с модификатором Асинх можно использовать оператор Ждать

- модификатор Асинх можно использовать только для клиентских процедур и функций

- В процедурах и функциях с модификатором Асинх параметры всегда передаются по значению. При этом неважно, будет ли в описании метода использоваться ключевое слово Знач перед параметром или нет

- Если в асинхронном методе произошло исключение, то метод вернет обещание, в которое завернуто исключение

- ~~Асинхронные процедуры не могут возвращать ничего, поэтому к ним непременим оператор `ждать`~~

```bsl
&НаКлиенте
Асинх Функция ПолучитьЗначениеИзВнешнейСистемы()
    Возврат 5 / 0;   //деление на ноль
КонецФункции

&НаКлиенте // Вызывающий метод
Процедура ВывестиДанныеИзВнешнейСистемы(Команда)
    
    Попытка        
        ПолучитьЗначениеИзВнешнейСистемы();        
    Исключение        
        Сообщить(ОписаниеОшибки()); //в эту строку не попадем        
    КонецПопытки;
    
КонецПроцедуры
```

Если бы к результату метода `ПолучитьЗначениеИзВнешнейСистемы()` применить оператор `ждать`, то только тогда будет сгенерировано исключение
### Исключение в асинхронном методе

Если исключение возникло внутри асинхронной **функции**, то перехватить это исключение снаружи не получиться, если не использовать оператор `ждать`. Асинхронная фукнция, завершившаяся ошибкой, вернет `Обещание`, в которое завернуто исключение.

Асинхронная **процедура**, завершившаяся ошибкой, уже никак не может быть перехвачена для обработки исключения, так как асинхронная процедура ничего не возвращает.

Поэтому, если есть необходимость перехватывать исключения асинхронных процедур, тогда нужно сделать процедуры функциями.
```bsl
&НаКлиенте
Асинх Процедура Демо_ПопыткаИсключениеАсинх(Команда)
    
    Попытка
        ВызватьОшибкуАсинх_Процедура();
    Исключение
        текст = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()); // Недостижимый код
        Сообщение = Новый СообщениеПользователю;
        Сообщение.Текст = текст;
        Сообщение.Сообщить();
    КонецПопытки;
    
КонецПроцедуры
```

#1С #1С/Многопоточность #Threads/Async
#Syntax/1С/Async
## Отказ от модальности

Отказ от модальности начался в платформе 8.3.3 (июль 2013 года). Для того, чтобы обеспечить работу с базами 1С через браузер, в том числе на мобильных устройствах, потребовалось отказаться в конфигурациях от использования модальных окон, которые при открытии блокируют весь интерфейс браузера, включая остальные открытые окна и вкладки

Асинх методы доступны только на клиенте

Во встроенном языке существуют схожие способы реализации асинхронности, которые уже давно присутствуют в JavaScript:

- Использование методов обратного вызова (callback)
- Использование Обещаний (promise)

## Принцип работы методов обратного вызова (callback)

Представим, что у нас есть такая структура кода:

```bsl
Procedure MainSyncProc()
    
    // какие-то действия
    
    AsyncProc(new ОписаниеОповещения("OnCompleted"));
    
    // какие-то действия
    
EndProcedure

// Метод обратного вызова, callback
Procedure OnCompleted() //ПриЗавершении

EndProcedure
```

После вызова асинхронного метода `AsyncProc()` управление вернется к коду, вызвавшему этот метод (`MainSyncProc()`), не дожидаясь, когда `AsyncProc()` завершит свою работу. Когда `AsyncProc()` отработает, он оповестит о своем завершении и предоставит доступ к результату.

Оповещение о завершении происходит при помощи вызова процедуры `OnCompleted()`, описание которой передается в `AsyncProc()`. Эта процедура и называется методом обратного вызова (англ. callback – дословно “обратный звонок”), поскольку позволяет асинхронному методу `AsyncProc()` “связаться” с вызвавшим его кодом (`MainSyncProc()`)

Пусть есть следующий код на языке JavaScript:

```js
console.log('1');
console.log('2');
console.log('3');
```

Этот код последовательно выводит в консоль числа 1, 2 и 3. Это синхронный код.

Теперь модифицируем его – реализуем вывод числа 2 в консоль по таймеру, через 2 секунды:

```js
console.log('1');
setTimeout(LogTwoSecondsLater, 2000);
console.log('3');

function LogTwoSecondsLater() {
    console.log('2')
}
```

Асинхронная функция `setTimeout()` ожидает 2 секунды (вторым параметром функции указан период ожидания в миллисекундах: 2000 мс = 2 с), а затем вызывает функцию обратного вызова `LogTwoSecondsLater()`, переданную в качестве первого параметра.

Функция `setTimeout()` не блокирует основной поток. Скрипт не “зависнет” на 2 секунды, а продолжит выполнение. В консоль будут выведены числа 1, 3. И только через 2 секунды, когда сработает таймер, будет вызвана функция `LogTwoSecondsLater()`, в консоль будет выведено число 2.

Но во встроенном языке “1С:Предприятие” нельзя указывать функцию в качестве параметра другого метода. Поэтому приведенный ниже код иллюстрирует логику работы асинхронных функций с использованием метода обратного вызова, но является *синтаксически некорректным*:

```bsl
Процедура ДлительнаяЗагрузка()
    ЗагрузитьАсинхронно(ВыполнитьДействияПослеЗагрузки);
КонецПроцедуры

Процедура ЗагрузитьАсинхронно(МетодОбратногоВызова)
    //Действия для загрузки данных...
    МетодОбратногоВызова();
КонецПроцедуры

Процедура ВыполнитьДействияПослеЗагрузки()
    //Оповещение, что загрузка завершена. Действия после завершения загрузки...
КонецПроцедуры
```

Во встроенном языке асинхронный код с использованием методов обратного вызова реализован при помощи объекта `ОписаниеОповещения`. Этот объект содержит описание метода обратного вызова:

- Какую процедуру нужно выполнить после завершения асинхронного метода?
- В каком модуле она располагается?
- Какие параметры нужно в нее передать?
- Для того, чтобы правильно составить описание метода обратного вызова, корректно описать все необходимые параметры, удобно использовать Синтакс-помощник. В нем указаны все параметры метода обратного вызова, который будет выполнен при завершении асинхронного метода.

Например, для метода `ПоказатьВопрос()` после ответа пользователя на вопрос будет вызвана процедура со следующими параметрами:

- `РезультатВопроса`
- `ДополнительныеПараметры`

Рассмотрим пример. В нем задается вопрос пользователю, на который он может ответить Да или Нет. После того, как пользователь ответит на вопрос, в сообщении выводим, сколько времени ему потребовалось на ответ.

Для реализации такого функционала используется следующий код в модуле формы:

```bsl
&НаКлиенте
Процедура ЗадатьВопрос(Команда)
    
    ДопПараметры = Новый Структура("ВремяНачала", ТекущаяДата());
    ОпОп = Новый ОписаниеОповещения(
        "ПоказатьВопросЗавершение",
        ЭтотОбъект,
        ДопПараметры
    );
    ПоказатьВопрос(ОпОп, "Выполнить загрузку?", РежимДиалогаВопрос.ДаНет);
    Сообщить("Начало загрузки");
    
КонецПроцедуры

&НаКлиенте
Процедура ПоказатьВопросЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт
    
    Сообщить("Выбран вариант: " + РезультатВопроса);
    Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура") Тогда
        
        ВремяНачала = Неопределено;
        Если ДополнительныеПараметры.Свойство("ВремяНачала", ВремяНачала) Тогда
            
            ЗатраченноеВремя = ТекущаяДата() - ВремяНачала;
            ТекстСообщения = СтрШаблон(
                "Затраченное время: %1 %2",
                    ЗатраченноеВремя,
                    "с"
            );
            Сообщить(ТекстСообщения);
            
        КонецЕсли;
        
    КонецЕсли;
    
КонецПроцедуры
```

Выделим важные моменты в этом коде:

- Используется асинхронный метод `ПоказатьВопрос()`. В нем первым параметром передается описание оповещения. Оно сообщает системе, что после того, как пользователь ответит на вопрос, нужно вызвать метод `ПоказатьВопросЗавершение()`, расположенный в модуле этой же формы, и передать в него `ДопПараметры`.

- Методы обратного вызова могут располагаться:
    - в модуле формы,
    - общем модуле
    - в модуле команды
- Расположение метода указывается вторым параметром в конструкторе объекта ОписаниеОповещения.

- Метод `ПоказатьВопросЗавершение()` обязательно должен быть **экспортным**, даже если он располагается в модуле той же формы. Если не указать ключевое слово `Экспорт`, то будет выдана ошибка

Поскольку метод `ПоказатьВопрос()` – асинхронный, после вызова этого метода управление вернется к коду, вызвавшему его, не дожидаясь, когда асинхронный метод завершит свою работу. Поэтому сообщение о начале загрузки появится до того, как пользователь ответит на вопрос. В этом заключается важное отличие асинхронного метода от синхронного.
Синхронный метод `Вопрос()` блокирует поток выполнения команд, поэтому следующая команда может быть выполнена только после того, как пользователь ответит на вопрос.

Если нужно выполнять какие-то действия после того, как пользователь ответит на вопрос, то эти действия нужно выполнять в методе `ПоказатьВопросЗавершение()`, а не сразу после вызова метода `ПоказатьВопрос()`. Это также связано с тем, что метод `ПоказатьВопрос()` является асинхронным.

После ответа пользователя на вопрос будет вызвана отдельная процедура. Может потребоваться передать в нее какие-то данные, необходимые для дальнейшей работы. Для этого можно использовать `ДополнительныеПараметры` – второй параметр метода ПоказатьВопросЗавершение. В нашем примере нужно знать время начала, когда пользователю был показан вопрос. Поэтому время начала передается в метод обратного вызова через `ДополнительныеПараметры`.

>У всех встроенных асинхронных методов может быть ряд параметров, которые передаются в обработчик завершения. В зависимости от конкретно используемого асинхронного метода, параметы обработчика завершения могут отличаться. Чтобы узнать, какие параметры должен ожидать обработчик, можно открыть синтаксис помощник.

**В каком потоке выполняется обработчик завершения?**

>Обработчик завершения выполняется в главном потоке, то есть в том же потоке, в котором обрабатывается интерфейс приложения.

**Почему он выполняется в основном потоке?**

На это есть, как минимум, 2 причины:

1. **Конкурентный доступ к интерфейсу**. Если фоновый поток и основной поток одновременно будут пытаться получить доступ к интерфейсу, то могут возникнуть коллизии и непредвиденные ошибки
2. **Нарушение логики приложения**. Взаимодействие с интерфейсом в фоновом потоке может нарушить правильный порядок выполнения кода. К тому же, параллельный доступ может нарушить состояние данных.

> Как можно заметить, все асинхронные (callback) методы именуются согласно определенным правилам. Асинхронные callback-методы обычно начинаются со слов: **Показать**, **Начать**

### Явный вызов callback-методов

Явного вызова обработчиков оповещений из программного кода, в приведенном примере, не происходило.

Во встроенном языке есть метод **`ВыполнитьОбработкуОповещения()`**, который используется для того, чтобы явно выполнить метод обратного вызова, указанный в качестве параметра. Такое действие может потребоваться в сложных случаях, когда асинхронные методы “вложены” друг в друга, и после цепочки асинхронных вызовов нужно выполнить действие, определенное раньше, еще до начала этих асинхронных вызовов.

В качестве примера рассмотрим следующую задачу. Необходимо открыть форму для выгрузки данных во внешнюю систему. Выгрузку можно производить только в том случае, когда в константе Лицензия заполнены данные лицензии для выгрузки. Если лицензия не заполнена, нужно предложить пользователю ввести данные лицензии, сохранить их в константе, после чего открыть форму для выгрузки данных во внешнюю систему.

Для начала рассмотрим синхронный код, решающий поставленную задачу:

```bsl
&НаКлиенте
Процедура ОтправитьВоВнешнююСистему(Команда)
    
    ДанныеДляВнешнейСистемы = Новый Структура;
    ДанныеДляВнешнейСистемы.Вставить("Дата",     ТекущаяДата()    );
    ДанныеДляВнешнейСистемы.Вставить("Описание", "ОписаниеПлатежа");
    //...
    
    Если ПроверитьЛицензию() Тогда
        
        //Открыть форму подключения к внешней системе
        ОткрытьФорму(
            "Обработка.ПодключениеКВнешнейСистеме.Форма",
            ДанныеДляВнешнейСистемы
        );
        
    Иначе
        
        ТекстВопроса = "Для подключения к внешней системе необходимо указать данные лицензии.
            |Ввести сейчас?";
        Ответ = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет);
        Если Ответ = КодВозвратаДиалога.Да Тогда
            
            Лицензия = "";
            ВвестиСтроку(Лицензия, "Лицензия");
            
            Если НЕ ПустаяСтрока(Лицензия) Тогда
                СохранитьЛицензию(Лицензия);
                
                //Открыть форму подключения к внешней системе
                ОткрытьФорму(
                    "Обработка.ПодключениеКВнешнейСистеме.Форма",
                    ДанныеДляВнешнейСистемы
                );
            КонецЕсли;
            
        КонецЕсли;
        
    КонецЕсли;
    
КонецПроцедуры


&НаСервереБезКонтекста
Функция ПроверитьЛицензию()
    
    Лицензия = Константы.Лицензия.Получить();
    Возврат ЗначениеЗаполнено(Лицензия);
    
КонецФункции


&НаСервереБезКонтекста
Процедура СохранитьЛицензию(Лицензия)
    
    Константы.Лицензия.Установить(Лицензия);
    
КонецПроцедуры
```

Синхронный программный код достаточно компактный, легко читается, удобен для анализа. В нем встречаются методы `Вопрос()` и `ВвестиСтроку()`. Нужно заменить их на асинхронные аналоги `ПоказатьВопрос()` и `ПоказатьВводСтроки()`, создать описания оповещений и разделить код на отдельные процедуры, поскольку после вызова асинхронного метода управление вернется к коду, вызвавшему его, не дожидаясь, когда асинхронный метод завершит свою работу.

Получится следующий асинхронный код:

```bsl
&НаКлиенте // (1) Синхронный
Процедура ОтправитьВоВнешнююСистему(Команда)
    
    ДанныеДляВнешнейСистемы = Новый Структура;
    ДанныеДляВнешнейСистемы.Вставить("Дата",     ТекущаяДата()    );
    ДанныеДляВнешнейСистемы.Вставить("Описание", "ОписаниеПлатежа");
    //...
    
    ОбработкаПродолжения = Новый ОписаниеОповещения(
        "ОтправитьВоВнешнююСистемуПродолжение",
        ЭтотОбъект,
        ДанныеДляВнешнейСистемы
    );
    НачатьПроверкуЛицензииИПодключениеКВнешнейСистеме(ОбработкаПродолжения);
    
КонецПроцедуры


&НаКлиенте // (2) Асинхронный
Процедура НачатьПроверкуЛицензииИПодключениеКВнешнейСистеме(
    ОбработкаПродолжения) Экспорт
    
    Если ПроверитьЛицензию() Тогда                                  // (3)
        ВыполнитьОбработкуОповещения(ОбработкаПродолжения, Истина); // (4.a)
    Иначе
        ПоказатьВопросВводаЛицензии(ОбработкаПродолжения);          // (4.b)
    КонецЕсли;
    
КонецПроцедуры


&НаСервереБезКонтекста // (3) Синхронный
Функция ПроверитьЛицензию()
    Лицензия = Константы.Лицензия.Получить();
    Возврат ЗначениеЗаполнено(Лицензия);
КонецФункции


&НаКлиенте // (4.a) Callback
Процедура ОтправитьВоВнешнююСистемуПродолжение(
    ЕстьЛицензия,
    ДанныеДляВнешнейСистемы) Экспорт
    
    Если НЕ ЕстьЛицензия Тогда
        Возврат;
    КонецЕсли;
    
    //Открыть форму подключения к внешней системе
    ОткрытьФорму(
        "Обработка.ПодключениеКВнешнейСистеме.Форма",
        ДанныеДляВнешнейСистемы
    );
    
КонецПроцедуры


&НаКлиенте // (4.b) Асинхронный
Процедура ПоказатьВопросВводаЛицензии(ОбработкаЗавершения)
    
    ПараметрыЗавершения = Новый Структура;
    ПараметрыЗавершения.Вставить("ОбработкаЗавершения", ОбработкаЗавершения);
    
    ОбработкаОтвета = Новый ОписаниеОповещения(
        "ПоказатьВопросВводаЛицензииЗавершение",
        ЭтотОбъект,
        ПараметрыЗавершения
    );
    
    ТекстВопроса = "Для подключения к внешней системе необходимо указать данные лицензии.
        |Ввести сейчас?";
    ПоказатьВопрос(ОбработкаОтвета, ТекстВопроса, РежимДиалогаВопрос.ДаНет);
    
КонецПроцедуры


&НаКлиенте // (5) Callback
Процедура ПоказатьВопросВводаЛицензииЗавершение(Ответ, Параметры) Экспорт
    
    Если Ответ = КодВозвратаДиалога.Да Тогда
        
        ОбработкаПодключения = Новый ОписаниеОповещения(
            "ВводЛицензииЗавершение",
            ЭтотОбъект,
            Параметры
        );
        ПоказатьВводСтроки(ОбработкаПодключения, "", "Лицензия");
        
    Иначе
        
        ВыполнитьОбработкуОповещения(Параметры.ОбработкаЗавершения, Ложь);
        
    КонецЕсли;
    
КонецПроцедуры


&НаКлиенте // (6) Callback
Процедура ВводЛицензииЗавершение(ВведеннаяСтрока, Параметры) Экспорт
    
    Если ПустаяСтрока(ВведеннаяСтрока) Тогда
        ВыполнитьОбработкуОповещения(Параметры.ОбработкаЗавершения, Ложь);
    Иначе
        СохранитьЛицензию(ВведеннаяСтрока);
        ВыполнитьОбработкуОповещения(Параметры.ОбработкаЗавершения, Истина);
    КонецЕсли;
    
КонецПроцедуры

&НаСервереБезКонтекста // (7) Синхронный
Процедура СохранитьЛицензию(Лицензия)
    
    Константы.Лицензия.Установить(Лицензия);
    
КонецПроцедуры
```

Для удобства, методы в примере пронумерованы в последовательности их выполнения


### Сложности при использовании методов обратного вызова

На этом примере можно увидеть, что отследить, что вообще происходит в коде затруднительно. Поэтому от данной асинхронной модели во многих языках программирования произошел переход на более прозрачную модель **обещаний**. 

В языках программирования, в которых можно передавать функцию как параметр другой процедуры, например, в JavaScript, есть такой термин, как *callback hell* (англ. – ад обратных вызовов) – многократно вложенные друг в друга блоки. В качестве примера можно привести следующий код:

```js
function callbackHell(){
    step1(function() {
        step2(function() {
            step3(function() {
                step4(function() {
                    step5(function() {
                        //...
                    });
                });
            });
        });
    });
}
```

В последнем примере кода 1С разобраться не так просто, а когда речь идет о нескольких уровнях вложенности обратных вызовов, то разобраться становится на порядки сложнее. В 1С это еще осложняется тем, что нельзя передавать ссылку на функцию или экземпляр функции как объект, что могло бы упростить восприятие.

Также сложно разобраться в сильно фрагментированном коде (особенно в типовых конфигурациях), поскольку отдельная процедура сама по себе не дает полного представления, что именно делает программный код. Нужно обязательно отследить всю цепочку процедур, выяснить взаимосвязи между процедурами, только тогда можно разобраться, как работает этот код.

### Встроенные средства упрощения создания методов обратного вызова

Существует специальный конструктор методов обратных вызовов, который находится:

* В конфигураторе
    * во вкладке текст
        * Рефакторинг
            * **Создать обработку оповещения**

Если установить курсор на имени асинхронного метода, после которого следует открывающаяся скобка, например, ПоказатьВопрос, НачатьПеремещениеФайла и т.д., то в меню станет доступна команда Создать обработку оповещения, которая самостоятельно сформирует описание оповещения и метод обратного вызова.

#### Преобразование синхронных вызовов

Этот инструмент рефакторинга помогает преобразовать код, содержащий синхронный метод, в код с использованием соответствующего асинхронного метода. Также при этом создается описание оповещения и метод обратного вызова.

Рассмотрим пример

```bsl
&НаКлиенте
Процедура ЗагрузитьДанные()
    
    Ответ = Вопрос("Выполнить загрузку?", РежимДиалогаВопрос.ДаНет);
    Если Ответ = КодВозвратаДиалога.Да Тогда
        //Логика загрузки
    КонецЕсли;
    
КонецПроцедуры
```

Установим курсор на метод `Вопрос()` и вызовем команду **Преобразовать вызов**. Получим следующий код с использованием асинхронного метода `ПоказатьВопрос()`

```bsl
&НаКлиенте
Процедура ЗагрузитьДанные()
    
    Ответ = Неопределено;
    ПоказатьВопрос(
        Новый ОписаниеОповещения(
            "ЗагрузитьДанныеЗавершение",
            ЭтаФорма
        ),
        "Выполнить загрузку?",
        РежимДиалогаВопрос.ДаНет
    );
    
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьДанныеЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт
    
    Ответ = РезультатВопроса;
    Если Ответ = КодВозвратаДиалога.Да Тогда
        //Логика загрузки
    КонецЕсли;
    
КонецПроцедуры
```

Команда Преобразовать вызов работает только с одним участком кода. Часто требуется проанализировать целый модуль, найти в нем “нерекомендуемые синхронные методы”, чтобы заменить их на асинхронные аналоги. Для этого существует команда Найти вызовы модуля. Найденные строки кода, содержащие “нерекомендуемые синхронные вызовы”, выводятся в окно с результатами поиска

##### Анализ нерекомендуемых синхронных вызовов

Команда **Найти** вызовы модуля ищет синхронные методы только в одном модуле. Если нужно проанализировать такие вызовы во всей конфигурации, то можно воспользоваться командой в меню **Конфигурация – Рефакторинг – Анализ нерекомендуемых синхронных вызовов конфигурации**

![[1С_Async1.png]]

Этот инструмент умеет не только находить синхронные вызовы во всех модулях конфигурации, но и выполнять автоматическую замену на соответствующие асинхронные методы в простых случаях. Также есть возможность создавать заготовки для методов обратного вызова.

Далее: [[]]





#Syntax/1С/Async

**[ПРОДОЛЖЕНИЕ](https://wonderland.v8.1c.ru/blog/uluchsheniya-v-sintaksise-yazyka-1s-dlya-raboty-s-asinkhronnymi-funktsiyami/)**
[2й источник](https://infostart.ru/1c/articles/1702526/)

[ОПА сохранить Источник](https://xn----1-bedvffifm4g.xn--p1ai/news/async-metods-article/)

Асинхронные методы в 1С такие же, как и везде. Асинхронный метод выполняется в фоновом потоке параллельно с основным. В недавней версии (по состоянию на 2024 год) в версии 8.3.18 был добавлен специальный синтаксис и тип:

```bsl
асинх процедура ИмяПроцедуры(<параметры>) //async
  [ждать] <Обещание>;                     //await
конецПроцедуры

асинх функция ИмяФункции(<параметры>)
  возврат <Значение>;
конецФункции
```

>Все параметры асинхронных функций передаются только **по значению**

Любая асинхронная функция возвращает **`Обещание`** или **`Promise`**.

>***Обещание*** (аналог C# — тип `Task`) — это контейнер, который содержит в себе значение некоторого типа. Предполагается, что в будущем `Обещание` вернет результат, но это не гарантировано. Например, существует обещание: получить данные из БД. Такое "обещание" говорит, что после выполнения операции получения данных из БД, мы сможем использовать результат обещания, но пока запрос к БД не выполниться, мы будем ждать результата, параллельно выполняя основную логику программы.

Существует 3 исхода выполнения асинхронной функции:

1. Мы **дождались** выполнения асинхронного метода и получили результат.
2. Мы **ждем** выполнения асинхронного метода и не получили результат, так как метод все еще выполняется. Возможно, асинхронный метод будет выполняться бесконечно.
3. Мы **не дождались** результата, так как асинхронный метод завершился с ошибкой (вернул `Неопределено`).

Как можно понять, нельзя всегда гарантированно получить результат, поэтому был введен тип `Обещание`, который обрабатывает такую логику и допускает все перечисленные состояния.

Оператор `ждать` может быть использован только внутри асинхронного метода. Этот оператор говорит, что нужно остановить выполнение кода и ждать до тех пор, пока `Обещание` не вернет значение. Если не использовать `ждать`, то ожадания не будет и код продолжит свое выполнение.

### Исключение в асинхронном методе

Если исключение возникло внутри асинхронной **функции**, то перехватить это исключение снаружи не получиться, если не использовать оператор `ждать`. Асинхронная фукнция, завершившаяся ошибкой, вернет `Обещание`, в которое завернуто исключение.

Асинхронная **процедура**, завершившаяся ошибкой, уже никак не может быть перехвачена для обработки исключения, так как асинхронная процедура ничего не возвращает.

Поэтому, если есть необходимость перехватывать исключения асинхронных процедур, тогда нужно сделать процедуры функциями.

### Описание оповещения

В предыдущих версиях асинхронные методы самостоятельно создавать было нельзя. Использовались только встроенные методы, которые в качестве параметра получают некий объект `ОписаниеОповещения`, который содержит информацию о том, какой метод вызвать после завершения асинхронного метода.

Такой подход вынуждает создавать 2 функции вместо одной, если не использовать новый синтаксис.

У большинства встроенных асинхронных методов есть параметр, в который помещается обработчик завершения этого метода. Обработчик завершения представлен типом "ОписаниеОповещения"

>ОписаниеОповещения — это объект, который содержит информацию о методе, который нужно выполнить после завершения асинхронного метода. Обработчик завершения должен быть **экспортным** (открытым)

```bsl
ОпОп = новый ОписаниеОповещения;

// или конструктор с инициализацией

ОпОп = новый ОписаниеОповещения(
    // Имя ЭКСПОРТИРУЕМОЙ процедуры
    имяПроцедуры,
    
    //Модуль, в котором определена процедура
    //Тип: ФормаКлиентскогоПриложения, ОбщийМодуль, Строка, Команда..
    модульПроцедуры,
);
```

Если основная процедура **оповещения** определена в том же модуле, где происходит вызов асинхронной процедуры, то можно в качестве модуля передать ссылку на текущий модуль.

```bsl
оповещение = новый ОписаниеОповещения("ПроцедураПослеВводаЗначения", ЭтотОбъект);
ПоказатьВводЗначения(оповещение, ...);
```

>У всех встроенных асинхронных методов может быть ряд параметров, которые передаются в обработчик завершения. В зависимости от конкретно используемого асинхронного метода, параметы обработчика завершения могут отличаться. Чтобы узнать, какие параметры должен ожидать обработчик, можно открыть синтаксис помощник.

**В каком потоке выполняется обработчик завершения?**

>Обработчик завершения выполняется в главном потоке, то есть в том же потоке, в котором обрабатывается интерфейс приложения.

**Почему он выполняется в основном потоке?**

>На это есть, как минимум, 2 причины:

1. **Конкурентный доступ к интерфейсу**. Если фоновый поток и основной поток одновременно будут пытаться получить доступ к интерфейсу, то могут возникнуть коллизии и непредвиденные ошибки
2. **Нарушение логики приложения**. Взаимодействие с интерфейсом в фоновом потоке может нарушить правильный порядок выполнения кода. К тому же, параллельный доступ может нарушить состояние данных.

>Как правило, имена асинхронных методов начинаются со слов "начать", "показать"

* Модификатор `асинх` можно использовать только для функций, выполняющихся на клиенте.

#1С #Threads/Async #1С/Многопоточность
**Источник: [Infostart: Составные типы — бесплатный сыр мышеловки производительности](https://infostart.ru/1c/articles/184361/)**

Составной тип данных — это объединенный тип данных, который подразумевает возможность хранения данных с разными типами.

Наиболее эффективно использование составных типов данных в случае необходимости хранить ссылку на несколько объектов конфигурации. Это упрощает логику работы с реквизитом, хранящим эту ссылку. Однако есть несколько негативных особенностей составных типов данных:

- **Размер данных**: Каждый примитивный тип данных в составном типе хранится как отдельное поле в БД. Таким образом, составной занимает больше памяти
- **Индексация**: При индексировании составного типа создаются индексы для каждого примитивного типа данных, входящего в составной тип. Это может привести к созданию большого количества индексов, что негативно сказывается на производительности запросов и требует дополнительных ресурсов при вставке, изменении или удалении записей
- Приходится анализировать тип данных, хранящихся в реквизите составного типа, применяя проверку типа
- Составные типы, содержащие ссылки, менее проблематичны по сравнению с теми, которые включают основные типы данных (строки, числа, дата и т.д.)
- Запрос к БД: При выборке поля составного типа (без использования `ВЫРАЗИТЬ`), неявно происходит выбор всех скрытых полей составного типа (выбирается каждый простой тип отдельно)
- **Проверка заполения**: При проверке заполнения реквизитов, содержащие Составной тип, можно использовать только функцию `ЗначениеЗаполнено()`, так как пока тип не выбран, такой реквизит содержит значение `неопределено`. Любой другой метод проверки заполнения приведет к ошибке
- При использовании языка запросов и составных типов, нужно сильно избегать выбор полей составных типов, содержащие примитивные типы, так как это сильно уменьшает производительность
- **`ВЫРАЗИТЬ()`**: При всех отборах и соединениях составных типов обязательно следует использовать метод `ВЫРАЗИТЬ()`. Если этого не сделать, реквизит соединится с составным типом данных по всем таблицам, из которых этот тип состоит, после чего уже отсекаются ненужные. `ВЫРАЗИТЬ()` отсекает ненужные таблицы заранее, сильно влияя на эффективность Запроса

>Составные типы данных являются весьма ресурсоемкими, поэтому нужно дважды подумать над тем, нужно ли использовать составной тип в данной задаче.

>Составной тип, состоящий только из ссылок гораздо лучше составного типа, содержащего в себе примитивные типы, такие как Строка, Число, Дата

## Как хранятся данные составного типа в базе данных

На первый взгляд всё достаточно просто. Поле составного типа в базе данных представляется двумя, тремя или большим количеством отдельных полей:


| Хранимые поля                  | Объем                                                                                                                                                                                                                 | Описание                                                                                                                                       |
| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **Идентификатор типа**         | **1 байт**                                                                                                                                                                                                            | двоичные данные, 1 байт, есть почти всегда, кроме поля "Регистратор" регистров, Ссылка в таблицах журналов и подобных "всегда ссылочных" полей |
| **Строка фиксированной длины** | зависит от максимальной длины строки                                                                                                                                                                                  | Предназначено для хранения строки, если в составной тип входит тип **`Строка`**. Хранение строки с неограниченной длиной невозможно            |
| **Число**                      | **5**, **9**, **13** или **17 байт** (для количества цифр 1-9, 10-19, 20-28 и 29-38 [соответственно](https://infostart.ru/redirect.php?url=aHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTg3NzQ2LmFzcHg=)) | Если допускается число                                                                                                                         |
| **Двоичные данные**            | **1 байт**                                                                                                                                                                                                            | Если допускается булево значение                                                                                                               |
| **Поле типа `datetime`**       | **8 байт**                                                                                                                                                                                                            | Если допускается дата или время                                                                                                                |
| **Вид ссылки**                 | **4 байта**                                                                                                                                                                                                           | Если допускается несколько видов ссылок (Справочник, Документ, Перечисление...)                                                                |
| **Ссылка**                     | **16 байт**                                                                                                                                                                                                           | Если допускается хранение хотя бы какого-то ссылочного типа                                                                                    |

Незаполненные поля составного значения хранят максимальное значение

В самом простом случае, если, например, мы индексируем составное поле справочника (без доп. упорядочивания), будет построено несколько индексов на каждый базовый тип:

- **Для поиска по числовым значениям**: Идентификатор типа + Число + Ссылка на элемент справочника
- **Для поиска по строковым значениям**: Идентификатор типа + Строка + Ссылка на элемент справочника
- **Для поиска по булеву значению**: Идентификатор типа + Булево + Ссылка на элемент справочника (блин, гениально "селективный" индекс)
- **Для поиска по дате/времени**: Идентификатор типа + Дата/время + Ссылка на элемент справочника
- **Для поиска по ссылке**: Идентификатор типа + Вид ссылки (если есть) + Ссылка на значение + Ссылка на справочник

**До пяти индексов**. К счастью, в самом частом случае, когда в составном типе возможно несколько ссылочных полей, и нет других типов, индекс всего один.

При том, индексы не всегда применяются при выполнении запросов к БД. Получается, что в таких случаях индексы вообще не нужны.

В случае измерений регистров составных типов данных, создается индекс на каждую комбинацию индексов, то есть в худшем случае, когда для составного типа создается 5 индексов, а в регистре 3 измерения такого составного типа, то в итоге будет создано **126** индексов ($5^3 + 1$ служебное внутреннее поле)

### Неявное создание переменных составных типов

```bsl
ВЫБРАТЬ  
    Справочник1.Ссылка КАК СсылкаЛиЭто  
ИЗ  
    Справочник.Справочник1 КАК Справочник1  

ОБЪЕДИНИТЬ ВСЕ

ВЫБРАТЬ 0
```

В этом запросе, тип получаемого поля `СсылкаЛиЭто` расширяется до составного типа, содержащего число. Чуть менее очевидно, что тип становится составным если вместо 0 выбрать `НЕОПРЕДЕЛЕНО`.

**Рекомендация**: если в запросе нужно пустое значение, но по каким-то причинам невозможно точно указать тип поля, то можно использовать `NULL`, если это не нарушает логику работы запроса.

Вы всё еще думаете, что проклятие составных типов вас не коснётся? ОК, пусть у вас есть регистр накопления `ОстаткиНоменклатуры` с двумя типами регистраторов: `ПриходнаяНакладная` и `РасходнаяНакладная`. Вы всего-навсего хотите узнать все товары, участвующие в движениях по нескольким документам. Ссылки на документы поместили **в массив**, написали очевидный запрос:

```bsl
ВЫБРАТЬ РАЗЛИЧНЫЕ  
    ОстаткиНоменклатуры.Номенклатура  
ИЗ  
    РегистрНакопления.ОстаткиНоменклатуры КАК ОстаткиНоменклатуры  
ГДЕ  
    ОстаткиНоменклатуры.Регистратор В(&ФильтрДокументов)
```

В `ФильтрДокументов` ссылки всего на 2 документа: 1 на `ПриходнаяНакладная` и 1 на `РасходнаяНакладная`. Сколько времени будет выполняться запрос? Упс. Сюрпри-и-из! Индекс по регистратору не используется! В плане запроса можно будет наблюдать сканирование кластеризованного индекса (если измерение `Номенклатура` не индексировано) или сканирование индекса по измерению `Номенклатура` (если такой индекс есть). В любом случае, такой запрос вместо ожидаемых долей секунды может начать работать минуты. Всё потому, что выражение `ГДЕ ОстаткиНоменклатуры.Регистратор В(&ФильтрДокументов)` в данном случае преобразуется в `WHERE (T1.Регистратор[Вид] + T1.Регистратор[Ссылка]` `IN (ПриходнаяНакладная[Вид] + ПриходнаяНакладная[Ссылка], РасходнаяНакладная[Вид] + РасходнаяНакладная[Ссылка]))`. Конкатенация (сцепка) бинарных данных убила возможность использовать индекс. Если ссылки в массиве будут одного вида, то 1С:Предприятие выстроит запрос к СУБД так, что индекс будет использоваться.

Для небольших списков в фильтрах можно изменить такой запрос на что-нибудь вроде:

```bsl
ВЫБРАТЬ РАЗЛИЧНЫЕ  
    ОстаткиНоменклатуры.Номенклатура  
ИЗ  
    РегистрНакопления.ОстаткиНоменклатуры КАК ОстаткиНоменклатуры  
ГДЕ  
    ОстаткиНоменклатуры.Регистратор = &Документ1   
    ИЛИ ОстаткиНоменклатуры.Регистратор = &Документ2  
    ИЛИ ОстаткиНоменклатуры.Регистратор = &Документ3
```

Я считаю, что примененное решение `WHERE (T1.Регистратор_Вид + T1.Регистратор_Ссылка IN (ЧтоТо_Вид + ЧтоТо_Ссылка, ЧтоТо_Вид + ЧтоТо_Ссылка))` в 1С:Предприятии ошибочным в принципе. Есть же альтернативы, например то, как реализовано выражение `(Поле1, Поле2) В (...)` через `EXISTS`. Если уж так тяжело это реализовать, то можно наоборот — всегда хранить полную двадцатибайтную ссылку в одном поле и оперировать ею. Ну или еще какие-нибудь решения.

>Передаваемые в запрос параметры типов `Массив`, `СписокЗначений`, `ТаблицаЗначений` могут содержать составные типы (или значения нескольких типов), и это может ухудшить работу запроса, особенно условие "`В (&Фильтр)`"

>Для получения реквизита значения составного типа происходит несколько левых соединений, их может быть достаточно много и это может ухудшить работу запроса. Для получения реквизита от реквизита значения составного типа (`Поле1.Реквизит1.Реквизит2`, где хотя бы `Поле1` составное) используются крайне громоздкие и неэффективные конструкции.

#### МИНИМУМ() и МАКСИМУМ()

>Нужно избегать использование функций `МИНИМУМ()`, `МАКСИМУМ()` для составных типов, так как происходит попытка нахождения максимального/минимального значения для каждого возможного типа в составном типе

**Рекомендация**: если нужно получить одно значение (без группировок), то вместо

```bsl
ВЫБРАТЬ
    МИНИМУМ(Т.СоставноеПоле) КАК СоставноеПоле
ИЗ
    Т КАК Т
```

можно использовать следующий запрос

```bsl
ВЫБРАТЬ ПЕРВЫЕ 1
    Т.СоставноеПоле КАК СоставноеПоле
ИЗ
    Т КАК Т

УПОРЯДОЧИТЬ ПО
    СоставноеПоле ВОЗР
```

В этом случае индексы могут использоваться, хотя и не всегда. Да и выражение для вычисления значительно проще.

#### Выражение ВЫБОР

Выражение `ВЫБОР` следует использовать очень осторожно, если в нём используются составные типы. Основной эффект состоит в том, что такое выражение быстро усложняется и обрастает неочевидными вычислениями.

```bsl
ВЫБРАТЬ
    ВЫБОР
        КОГДА Т.ТипПоля = "Документ.ПриходнаяНакладная"
            ТОГДА Т.СоставноеПоле
    КОНЕЦ КАК Поле1
ИЗ
    Т КАК Т
```

Этот запрос будет выполняться как

```bsl
ВЫБРАТЬ
    ВЫБОР
        КОГДА Т.ТипПоля = "Документ.ПриходнаяНакладная"
            ТОГДА Т.СоставноеПоле[Тип]
    КОНЕЦ КАК Поле1[Тип],
    ВЫБОР
        КОГДА Т.ТипПоля = "Документ.ПриходнаяНакладная"
            ТОГДА Т.СоставноеПоле[Число]
    КОНЕЦ КАК Поле1[Число],
    ВЫБОР
        КОГДА Т.ТипПоля = "Документ.ПриходнаяНакладная"
            ТОГДА Т.СоставноеПоле[Строка]
    КОНЕЦ КАК Поле1[Строка],
    ВЫБОР
        КОГДА Т.ТипПоля = "Документ.ПриходнаяНакладная"
            ТОГДА Т.СоставноеПоле[Вид]
    КОНЕЦ КАК Поле1[Вид],
    ВЫБОР
        КОГДА Т.ТипПоля = "Документ.ПриходнаяНакладная"
            ТОГДА Т.СоставноеПоле[Ссылка]
    КОНЕЦ КАК Поле1[Ссылка],
ИЗ
    Т КАК Т
```

Если нужно ограничить тип составного поля, то следует пользоваться операцией `ВЫРАЗИТЬ`:

```bsl
ВЫБРАТЬ
    ВЫРАЗИТЬ (Т.СоставноеПоле КАК Документ.ПриходнаяНакладная) КАК Поле1
ИЗ
    Т КАК Т
```

>Запрос `МИНИМУМ(...)` и `МАКСИМУМ(...)` в сочетании с `ВЫБОР` и составными типами нежизнеспособен.

Кроме полей в которых явно указано "Составной тип данных" есть еще:

1. Субконто в регистрах бухгалтерии
2. Регистраторы регистров (сведений, накопления, бухгалтерии, расчетов), причем не забудьте и про таблицы изменений
3. Регистры сведений с характеристиками, в том числе часто контактная информация
4. Графы и ссылки журналов документов
5. Таблицы последовательности документов



#1С #1С/Язык_программирования/Типы_данных

Большинство программистов используют высокоуровневые языки программирования. Современные компиляторы и интерапритаторы производят множество операций для ускорения выполнения кода. Оптимизация настолько велика, что код практически выполняется с наибольшей возможной скоростью. Компиляторы выполняют низкоуровневые оптимизации над данными лучше, чем какой-либо из программистов языков низкого уровня.

Как происходит оптимизация выполнения программы на низком уровне и на уровне ОС?

* Современные процессоры могут менять некоторые выполняемые команды местами для более оптимального испольования процессорного времени, при этом результат работы программы не меняется. \* Для блокировки такого поведения используются барьеры по памяти
* Пул потоков. ОС выделяет для программы какое-то множество потоков, которые будут подхватывать части программного кода и выполнять их, при этом потоки из пула потоков не удаляются, а ждут, пока планировщик не использует их. Оптимизация состоит в отсутствии лишних операций создания и удаления потоков.
* Виртуальные ядра. Современные процессоры имеют в 2 раза больше виртуальных ядер, чем физических. Когда одно из физических ядер простаивает, то его можно использовать другими процессами. Затем когда основной процесс снова занимает физическое ядро, вторичный процесс приостанавливается.

Программист не должен заниматься низкоуровневой оптимизацией, так как он может помешать работе транслятора. Не стоит делать ассемблерные вставки и проводить глубокую оптимизацию по памяти и т. д. Программист должен проводить только высокоуровневую, логическую оптимизацию программы. Должно соблюдаться разделение труда высокоуровневых программистов и низкоуровневых оптимизаторов.

## Оптимизация исходного кода

Трансляторы выполняют различные оптимизации кода программы, происходит удаление ненужных элементов, замена операций и другое, например:

* Неиспользуемые объявленные переменные удаляются
* Недостижимый код (например, после бесконечного цикла) удаляется
* **Свертка констант**. Простые переменные заменяются константами
* **Свертка общих выражений.** Например, в выражении `a+(b*a) - (a*b*c)` выражение `a*b` вычисляется только один раз.
* **Встраивание методов.** Вызов функции заменяется ее телом. Лучше работает для статических невиртуальных методов. Методы интерфейсов и виртуальные методы могут встраиваться частично или не встраиваться вообще, что приводит к ухудшению производительности.
* **Отключение проверки границ массива.**
* **Хвостовая рекурсия.** Каждый рекурсивный вызов функции создает кадр стека функции, но транслятор может не выделять кадр стека для новых вызовов, а использовать кадр первой функции, при условии, что рекурсивный вызов функции является последней (хвостовой) операцией в функции. (JIT-компилятор в .Net использует эту оптимизацию). Например, тело рекурсивной функции может быть заменено на тело, в котором вместо вызова функции используется оператор **`goto`** и образуется цикл.

В .Net оптимизация производится JIT-компилятором.

Перечисленные оптимизации происходят не всегда, так как для их реализации требуются определенные условия

Если рекурсия бесконечна и JIT-компилятор выполнил хвостовую оптимизацию, то исключения **`StackOverflow`** не произойдет, так как используется один и тот же кадр стека. Такое поведение приведет к бесконечному циклу.

#Dotnet #Performance #C-Sharp
>Синхронизация потоков — это механизм обеспечения правильной последовательности выполнения потоков при доступе к общим ресурсам.

В данном примере потоки пользуются **общим ресурсом** — целочисленной переменной **x**.
```cs
int x;
// Запускаем 5 потоков
for (int i = 1; i < 6; i++)
{
  Thread myThread = new(Print);
  myThread.Name = $"Поток {i}";
  myThread.Start();
}

// Выводим имя текущего потока и значение "x"
void Print()
{
  x = 1;
  for (int i = 1; i < 6; i++)
  {
    Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
    x++;
    Thread.Sleep(100); // задержка текущего потока
  }
}
```

Программа была запущена 3 раза. Ниже приведены выводы:

```
 Запуск №1  |  Запуск №2  |  Запуск №3
------------+-------------+------------
Поток 1: 1  | Поток 2: 1  | Поток 1: 1 
Поток 3: 1  | Поток 1: 1  | Поток 2: 1 
Поток 2: 1  | Поток 4: 1  | Поток 3: 1 
Поток 5: 1  | Поток 3: 1  | Поток 4: 1 
Поток 4: 1  | Поток 5: 1  | Поток 5: 1 
Поток 5: 6  | Поток 4: 6  | Поток 4: 6 
Поток 1: 6  | Поток 1: 6  | Поток 5: 6 
Поток 3: 6  | Поток 5: 6  | Поток 3: 6 
Поток 4: 6  | Поток 2: 6  | Поток 2: 6 
Поток 2: 6  | Поток 3: 6  | Поток 1: 6 
Поток 1: 11 | Поток 1: 11 | Поток 3: 11
Поток 2: 11 | Поток 2: 11 | Поток 4: 11
Поток 5: 11 | Поток 3: 11 | Поток 1: 13
Поток 4: 11 | Поток 5: 11 | Поток 2: 13
Поток 3: 11 | Поток 4: 11 | Поток 5: 13
Поток 4: 16 | Поток 1: 16 | Поток 4: 16
Поток 1: 16 | Поток 5: 16 | Поток 5: 16
Поток 3: 16 | Поток 2: 16 | Поток 1: 16
Поток 5: 16 | Поток 4: 16 | Поток 2: 16
Поток 2: 16 | Поток 3: 16 | Поток 3: 16
Поток 1: 21 | Поток 4: 21 | Поток 3: 21
Поток 2: 21 | Поток 5: 21 | Поток 2: 21
Поток 4: 21 | Поток 2: 21 | Поток 1: 21
Поток 5: 21 | Поток 1: 21 | Поток 4: 21
Поток 3: 21 | Поток 3: 21 | Поток 5: 21
```

Потоки выполнялись одновременно, для каждого потока вывод одинаковый. Потоков — 5, операций инкремента — 5, соответственно после первого вызова `Print()` значение "x" увеличилось на 5.

Из примера видно, что результат работы программы непредсказуем, то есть не ясно, какой поток "первым" повлияет на программу. Чтобы решить эту проблему, нужно синхронизировать потоки и ограничить доступ к разделяемым ресурсам.

>Критическая секция — это участок кода, в котором производится доступ к общему для потоков ресурсу. В критической секции может находиться только один поток.

## Оператор lock

Оператор **`lock`** обеспечивает монопольный доступ к общему ресурсу. Другими словами оператор определяет участок кода, который становится доступным только для указанного потока до тех пор, пока указанный поток не завершит работу с этим блоком кода.

Блок **`lock`**, практически, представляет собой критическую секцию.

Синтаксис:

```cs
lock(locked_resource)
{
	// My code...
}
```

На самом деле **`lock`** разворачивается в оператор **`try-finally`**. По этой причине любое вызванное исключение в блоке **`lock`** будет поглощено.

Аналогичный пример с оператором **`lock`**:

```cs
int x = 0;
// общий ресурс, заглушка
object locked_obj = new();

// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
  Thread myThread = new(Print);
  myThread.Name = $"Поток {i}";
  myThread.Start();
}

void Print()
{
  lock (locked_obj)
  {
    x = 1;
    for (int i = 1; i < 6; i++)
    {
      Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
      x++;
      Thread.Sleep(100);
    }
  }
}
```

Вывод:

```
Поток 1: 1
Поток 1: 2
Поток 1: 3
Поток 1: 4
Поток 1: 5
Поток 2: 1
Поток 2: 2
Поток 2: 3
Поток 2: 4
Поток 2: 5
Поток 3: 1
Поток 3: 2
Поток 3: 3
Поток 3: 4
Поток 3: 5
Поток 4: 1
Поток 4: 2
Поток 4: 3
Поток 4: 4
Поток 4: 5
Поток 5: 1
Поток 5: 2
Поток 5: 3
Поток 5: 4
Поток 5: 5
```

При запуске каждого следующего потока общая переменная обновляется и инкрементируется заново.

>Вопрос: Зачем объект-заглушка?

— оператор **`lock`** ожидает ссылочный объект, который будет заблокирован. В данном случае нам не требуется блокировать объекты и мы используем заглушку, нам нужно просто заблокировать нужный участок кода.

Число "x" может быть изменено параллельным потоком, но так как все потоки выполняют один и тот же блок кода, то изменение значения "x" нам не грозит. Если бы использовался сложный незаблокированный объект в блоке **`lock`**, то его свойства можно было бы изменить извне параллельно другим потоком.

Далее: [[Мониторы]]

#C-Sharp #C-Sharp/Threads #C-Sharp/Threads/Sync
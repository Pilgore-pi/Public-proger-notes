
Некоторые операции могут приводить к зависанию интерфейса, особенно в десктопных приложениях, при считывании данных из БД, из файла, при выполнении расчетов и т. д. Асинхронное выполнение кода позволяет избежать этой и других проблем, когда требуется независимое параллельное выполнение потоков.

**TPL (Task Parallel Library)** — библиотека параллельных задач. Находится в **`System.Threading.Tasks`**. В основе библиотеки лежит концепция **задачи** — отдельной продолжительной операции.

> При создании задачи, она передается планировщику, который передает ее на выполнение одному из фоновых потоков пула `ThreadPool`

Так как любой асинхронный поток — это фоновый поток, то основной поток программы при завершении завершит весь связанный с этим потоком процесс, что приведет к немедленному завершению всех фоновых потоков.

Для библиотеки TPL был разработан специальный синтаксис, упрощающий работу с ней.

**`Task`** — это класс процедур (`void`)
**`Task<T>`** — это класс методов с возвращаемыми значениями

* В других языках это понятие называется **Future** или **Promise**.

> `Task` — это именованная область памяти (переменная), которая **будет** хранить данные. То есть когда-то в будущем `Task` будет именть значение.

Конструкторы:

```csharp
Task(Action a);
Task(Action a, CancellationToken ct);
```

## Класс `Task`

### Методы

| Метод                                                         | Описание                                                                                                                                                                                                  |
| ------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`Start()`**                                                 | запускает выполнение задачи                                                                                                                                                                               |
| **`Task.Factory.StartNew(Action a)`**                         | создание и запуск новой задачи; возвращает задачу                                                                                                                                                         |
| **`Task.Run(Action a)`**                                      | аналогично **`Task.Factory.StartNew()`**                                                                                                                                                                  |
| **`Wait()`**                                                  | ожидание завершения запущенной задачи. Если другие действия в программе завершены, то она завершится не дожидаясь выполнения задач. Этот метод явно говорит проге, чтобы она подождала выполнение задачи. |
| **`Task.WaitAll(Task[] tasks[, int ms])`**                    | ожидание завершения всех указанных задач; **`ms`** —ожидание завершения в течении указанных миллисекунд.                                                                                                  |
| **`Task.WaitAny(Task[] tasks[, int ms])`**                    | ожидание любого из списка                                                                                                                                                                                 |
| **`Task.WaitAsync(TimeSpan)`**                                | возвращает другую задачу, которая ожидает завершение задачи, у которой был вызван этот метод.                                                                                                             |
| **`Task.Delay(int milliseconds)`**                            | возвращает задачу, которая ничего не далает, но завершается через определенное время.                                                                                                                     |
| **`ContinueWith(Func<Task, TResult>)`**                       | код. Задача А + продолжающий код — это новая задача. ожидает завершения задачи А, после этого выполняет какой-то                                                                                          |
| **`ContinueWhenAll<TResult>(Task[], Func<Task[], TResult>)`** | аналогичен приведенному вышеметоду, но ждет, пока все задачи из указанного массива завершаться, затем выполняет указанный код.                                                                            |
| **`ContinueWhenAny(Task[], Action<Task>)`**                   | обратный по логике метод                                                                                                                                                                                  |
| **`Task.WhenAll(Task[])`**                                    | **задача**, которая выполняется тогда, когда выполнены все задачи из списка. Можно применять оператор **`await`**                                                                                         |
| **`Task.WhenAny(Task[])`**                                    | когда хотя бы одна задача выполнена                                                                                                                                                                       |
| **`RunSynchronously()`**                                      | запуск задачи синхронно                                                                                                                                                                                   |

### Свойства

| Свойство             | Описание                                                                                                       |
| -------------------- | -------------------------------------------------------------------------------------------------------------- |
| **`AsyncState`**     | объект состояния задачи                                                                                        |
| **`Id`**             | идентификатор текущей задачи                                                                                   |
| **`Task.CurrentId`** | идентификатор текущей задачи                                                                                   |
| **`Exception`**      | объект исключения возникшего при выполнении задачи                                                             |
| **`Status`**         | статус задачи в виде перечисления **`TaskStatus`** (инф-ия о завершенности,  отмененности, выполнении и т. д.) |

## Класс `Task<T>`

Свойства **`Task<T>`**:

| Свойство     | Описание                |
| ------------ | ----------------------- |
| **`Result`** | "возвращаемое значение" |

> Асинхронный код имеет смысл делать только из асинхронных вызовов и с использованием соответствующих библиотек. Смешивание синхронного и асинхронного (**`Tasks`**) кода приводит к нарушению логики, в которой невозможно разобараться

Мир синхронных данных — это переменные. Мир асинхронных обещаний — это задачи. Task-и — это обертки для совместимости с синхронными данными.

Задачи выполняют функцию разграничения синхронного кода от асинхронного.

==??? обращение к **`Task<TResult>`** блокирует выполнение кода и при этом происходит ожидание, пока результат не будет вычислен.==

Пример:

```csharp
// Устаревший синтаксис
void Task AsyncMethod()
{
    var task = Task.Delay(2000);
    task.Wait();
    //code..
}

static void Main()
{
    var t = AsyncMethod();
    Console.WriteLine("Line 2");
    Console.WriteLine("Line 3");
    Console.WriteLine("Line 4");
}
```

Есть метод **`Main()`** & **`AsyncMethod()`**, они выполняются параллельно и независимо. В переменной **`t`** находится "обещание" того, что **`AsyncMethod()`** полностью выполниться и вернет какое-то значение в будущем (в данном случае его нет), отсюда и названия **Promise** и **Future** как аналоги **Task**. Тем временем выполняются 2-я, 3-я и 4-я строчки кода, пока выполняются строки кода асинхронного метода. При этом неизвестно, когда выполниться асинхронный метод, может раньше, может гороздо позже самого **`Main()`**, а может одновременно.

Таким образом встает проблема: "Как обрабатывать данные, которых еще нет?". Остается только ждать 🤷‍♀️

```csharp
var t1 = Task<int>.Run(() => GenerateInt(10));
var t2 = t1.ContinueWith(t1 => t.Result * 10);

//t2.Wait();
Console.WriteLine(t2.Result);

int GenerateInt(int x)
{
	Task.Delay(3000).Wait();
	return 2 * x;
}
// Ответ: 200
```

* Нельзя использовать неасинхронный **`Thread.Sleep()`** и другой неасинхронный код. Внутри `Task.Delay()` скрыто вызывается `Thread.Sleep()`

#### Вложенные задачи

```csharp
var outer = Task.Run(() =>
  var inner = Task.Run(some_action);
);

outer.Wait();
// End of Main
```

Вложенная задача выполняется независимо от внешней. Она может завершиться после того, как завершиться поток Main.

> Любой вызов асинхронной функции или вызов `Task.Run()` неявно назначает новый фоновый поток с новым идентификатором. Это происходит, даже, если мы в коде ожидаем завершения асинхронной функии, а потом вызываем новую асинхронную функцию

## Операторы `async` & `await`

Оператор **`async`**, говорит, что данный метод может быть асинхронным, то есть возвращать задачу. Кроме того, оператор говорит, что в методе допускается использование оператора **`await`** (аналог `Task.Wait()`)

Оператор **`await`** — это ожидание выполнения задачи. Поток, ожидающий выполнения задачи через `await`, будет простаивать до тех пор, пока фоновый поток не выполниться. Когда и если вызывающий поток дождался результата задачи, поток "просыпается" и продолжает выполнять код дальше

Если не использовать **`await`**, то ожидания не будет, метод будет продолжать работу в синхронном режиме, поэтому нет смысла делать метод асинхронным и не использовать **`await`**

```csharp
async Task Method(){
  var task1 = Task.Run(some_action1);
  var task2 = Task.Run(some_action2);
  var task3 = Task.Run(background_work); // Method() не ждет эту задачу
  
  await task1;
  await task2;
}
```

>Строки `var task1 = ...` & `var task2 = ...` выполняются одна за другой сразу, без ожидания, пока задачи запустятся и выполнятся. Другими словами, пока мы ждем `task1`, `task2` уже могла выполниться. Оператор `await`, в таком случае служит для порядка и контроля последовательного выполнения операций

Классический асинхронный код:

```csharp
var t = Task<int>.Run(() => GenerateInt(10));

int GenerateInt(int x)
{
	Task.Delay(3000).Wait();
	return 2 * x;
}
```

Современный синтаксис:

```csharp
var t = GenerateInt(10); // t.Type == Task

//тело задачи — это тело функции
//задача создается запущенной
async Task<int> GenerateInt(int x)
{
  await Task.Delay(3000); // Wait();
  return 2 * x; // значение идет в Task Result
}
// формальный результат задачи: int
```

> **Вызов асинхронной функции — это запуск задачи, а не получение результата**

оператор **`async`** можно применять к методам, возвращающим следующие типы:

* **`void`** — Не рекомендуется использовать с `async`, поскольку это может привести к трудноотловимым ошибкам, если метод завершится с исключением. Вместо этого следует использовать `Task`. Кроме того, `void` не позволяет отслеживать статус выполнения
* **`Task`** — Используется для асинхронных операций без возврата значения. Позволяет отслеживать статус задачи (`Created, WaitingToRun, Running, Cancelled, Faulted, etc.`)
* **`Task<T>`** — Используется для асинхронных операций с возвратом типизированного значения
* **`ValueTask`** — Предназначен для высокопроизводительных сценариев, где часто используется синхронное выполнение
    - Рекомендуется использовать вместо `Task`, когда известно, что задача часто будет завершена синхронно
    - Задача может быть выделена на стеке (stack), уменьшая накладные расходы по сравнению с `Task`
* **`ValueTask<T>`** — Аналогичен `ValueTask`, но позволяет возвращать значение

Типы **`void`** & **`Task`** могут быть использованы, когда в методе нет оператора **`return`**.

**`void`** стоит использовать только, когда другого выхода нет (события типа делегата **`Action`**), так как нельзя применять к методам **`void`** оператор **`await`**; исключения в таких методах трудно обрабатывать, так как они не могут быть перехвачены вне метода, в таком случае приходится обрабатывать исключения прямо в методе.

>Асинхронный метод не может иметь параметров **`in`**, **`ref`**, **`out`**

>Именовать асинхронные методы принято с окончанием "Async"

```csharp
public static async Task DelayOperationAsync()
{
  BeforeCall();
  Task task = Task.Delay(1000); //асинхронная операция
  AfterCall();
  await task;
  AfterAwait();
} 
```

### Различия Task & ValueTask

| `Task`                                                                                                          | `ValueTask`                                                                                                                                                                                                                                                           |
| --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Предназначен для активного использования метода в асинхронном режиме                                            | Предназначен для использования методов, которые могут выполниться синхронно (и делают это часто), без выделения фонового потока, при определенных обстоятельствах                                                                                                     |
| Подразумевает, что метод всегда будет выполняться в фоновом потоке, что позволяет использовать оператор `await` | Подразумевает, что метод не всегда будет выполняться асинхронно, что делает невозможным использование оператора `await`. Поскольку, если метод будет синхронным, то к нему нельзя будет применить оператор                                                            |
| Выделяется всегда на **куче**                                                                                   | Может выделяться на стеке, однако, если метод выполняется асинхронно, то будет создан объект `Task`, что делает нецелесообразным использование `ValueTask` в любых сценариях                                                                                          |
| Реализация — простая                                                                                            | Усложненная реализация метода из-за необходимости дополнительного контроля над состоянием задачи                                                                                                                                                                      |
| Обычно, даже, если `Task` медленнее, но это не критично, стоит использовать `Task`                              | Даже, если `ValueTask` позволяет увеличить производительность, может быть нецелесообразным его использование, если погрешность времени выполнения задачи слишком большая. Тогда уже не так важно при выполнении долгой операции, сколько миллисекунд было сэкономлено |
| Рекомендуется использовать всегда при возможности                                                               | В целом не рекомендуется использовать, кроме случаев, когда требуется критическая производительность                                                                                                                                                                  |

### Другие особенности асинхронного кода

> Если задача **`task`** в асинхронном методе успеет выполниться к моменту выполнения оператора **`await`**, то то остаток кода метода будет выполняться синхронно, в противном случае остаточный код метода сохраняется, чтобы выполнить его после завершения асинхронной операции **`task`** в новом потоке. В этом можно убедиться, обращаясь к ID потока на разных этапах выполнения метода

> Если ожидаемая задача не успевает выполниться к моменту оператора **`await`**, то остаток кода выгружается в новый поток один раз, при встрече других операторов **`await`** такого происходить уже не будет

> Асинхронные методы не выполняются, если они не были вызваны. При каждом новом вызове асинхронного метода создается новая задача

> Если метод **`Main()`** вызывает только 1 асинхронный метод и сам **`Main()`** является синхронным, то асинхронный метод может не выполниться полностью, так как метод **`Main()`** может завершиться раньше

> Одна задача может выполняться многими потоками и один поток может выполнять множество задач

Оператор **`await`** возвращает результат задачи, при этом ожидается ее выполнение:

```csharp
int res = await DoubleInt(10);

async Task<int> DoubleInt(int x)
{
  await Task.Delay(3000);
  return 2 * x;
}
```

В общем, нужно хорошо разбираться в этой теме и не мешать синхронный код, иначе можно утонуть в асинхронной логике. Это хорошо демонстрирует схема, на которой всего лишь 2 метода: асинхронный и синхронный:

![[TPL Library callback scheme.png]]

Как видно, из асинхронного метода вызывается синхронный метод (это нормальная практика)

Далее: [[Класс Parallel]]

#C-Sharp #C-Sharp/Threads/Async
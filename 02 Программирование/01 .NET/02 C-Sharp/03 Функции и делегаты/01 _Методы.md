> **Метод** — это именованный участок кода, который может быть выполнен несколько раз в различных участках программы

Методы могут иметь **параметры** и могут возвращать результат своей работы, в таком случае метод будет являться **функцией**, метод, который ничего не возвращает называется **процедурой**. Эти термины редко применяются в мире .Net (особенно "процедура"), обычно эти понятия обобщаются до термина "метод".

В основном классе программы (где находится метод `Main`) все методы должны быть статическими, так как основной класс программы может содержать только статические методы. В других классах методы могут быть не статическими.

Состав методов:

- Сигнатура — совокупность атрибутов, которые идентифицируют метод
    - Имя метода
    - Тип возвращаемого значения
    - Состав параметров
        - Количество
        - Тип каждого параметра
        - Модификатор каждого параметра
- Тело метода — код, который ассоциирован с именем метода

```csharp
// Метод без параметров и без возвращаемого значения (процедура)
static void ShowMessage()
{
    Console.WriteLine("Who are you?");
}

// Метод с параметром без возвращаемого значения
static void ShowMessage(string text)
{
    Console.WriteLine(text);
}

// Сокращенная запись. Доступна, если в теле метода одна строка кода
static void ShowMessage(string text) => Console.WriteLine(text);

// Метод с параметрами, возвращающий сумму чисел (функция)
static int GetSum(int n1, int n2, int n3, int n4)
{
    var result = n1 + n2 + n3 + n4;
    return result;
}
```

## Модификаторы параметров

> В данном разделе требуется понимание различий между типами значений и типами ссылок. Если вы не обладаете достаточными знаниями, пропустите этот раздел

Все параметры, которые передаются в методы по умолчанию передаются по значению. То есть типы значений копируются, а для ссылочных типов происходит копирование ссылки на данные.
Таким образом через дубликат ссылки на ссылочный тип можно редактировать его непосредственно в методе, но если мы попытаемся создать совершенно новый объект и поместим его в дубликат ссылки, то оригинальная ссылка будет продолжать указывать на старые данные.

```csharp
static void ChangeValue(int number) => number *= 2;
static void ChangeValue(string value) => value += value;

int number = 90;
ChangeValue(number);

Console.WriteLine(number); // 90 (не изменилось)

class NumberHolder { public int Number; }
class StringHolder { public string Value; }

NumberHolder holder = new();
holder.Number = 55;
ChangeValue(holder.Number);
Console.WriteLine(hloder.Number); // 55 (не изменилось)

StringHolder holder = new();
holder.Value = "FF";
ChangeValue(holder.Value);
Console.WriteLine(hloder.Value); // "FFFF" (изменилось)
```

Однако, если попытаться пересоздать объект, хранящий число, то в исходном объекте ничего не поменяется

```csharp
static void ChangeValueWithRecreation(StringHolder holder)
{
    holder = new();     // копия ссылки теперь указывает на другой объект
    holder.Value = 55;
    holder.Value *= 2; // 110
}

holder.Value = 55;
ChangeValueWithRecreation(holder); // оригинальная ссылка не изменена
Console.WriteLine(hloder.Value);  // 55 (не изменилось)
```

Тип `string` является неизменяемым типом (**[[16 Неизменяемые типы|Immutable]]**), то есть при попытке редактирования такой переменной значение не изменяется, а создается новый объект, в который копируется новое значение. Такая особенность этого типа приводит к тому, что строка передаваемая в метод не может быть изменена.

```csharp
string text = "ABC";
text = text + "DEFG"; // создание нового объекта string
```

> Модификатор `ref` позволяет передавать любые значения по ссылке

```csharp
static void ChangeValue(ref int number) => number *= 2;

int number = 90;
ChangeValue(number);
Console.WriteLine(number); // 180
```

Ссылочные типы передаваемые с модификатором `ref` не копируют ссылку, а непосредственно передают ссылку на объект, что позволяет иметь полноценный доступ к ссылочному объекту

#### Модификатор `in`

Это расширенная версия модификатора `ref`, которая позволяет передавать параметры по ссылке без возможности редактирования внутри метода.

```csharp
static void ChangeValue(in int number)
{
    // Ошибка компиляции, нельзя изменять параметры с модификатором in
    number += 2; 
    Console.WriteLine(number);
}
```

Параметры с модификатором `in` называются **входными**

#### Модификатор `out` ИНИЦИАЛИЗАЦИЯ ЧЕРЕЗ OUT

Модификатор `out` также является расширенной версией `ref`. Параметры с этим модификатором обязательно должны быть инициализированы внутри метода. Это позволяет передавать неинициализированные переменные в методы по ссылке, которые будут гарантировано инициализированы в результате выполнения метода.

```csharp
static void ChangeValue(out int number)
{
    number = 0;
    number += 2; 
    Console.WriteLine(number);
}
```

> Модификаторы `ref` и `out` должны применяться к параметру как в объявлении метода, так и при его вызове

Параметры с модификатором `out` называются **выходными**

#### Модификатор `params`

Модификатор `params` является синтаксическим сахаром, позволяющим передавать массив параметров в метод так, будто в метод передается неограниченное количество однотипных независимых параметров

```csharp
static double CalculateAverage(params double[] values)
{
    if (values.Length == 0) return 0;
    
    double sum = 0;
    foreach(var val in values) sum += val;
    
    return sum / values.Length;
}

var avg1 = CalculateAvarage(1.1, 1.5, 2.7, 3);
var avg2 = CalculateAvarage(1.1);
var avg3 = CalculateAvarage();
```


> Модификатор `params` должен быть последним в списке параметров, чтобы компилятор мог однозначно понимать, какие значение соотносятся с какими параметрами

## Необязательные параметры

В методах можно обявлять необязательные параметры, которые имеют значение по умолчанию

```csharp
int Sum(int n1, int n2 = 0)
{
    return n1 + n2;
}
```

Чтобы компилятор мог однозначно определить, какой параметр мы передаем в метод при его вызове, необходимо в объявлении этого метода необязательные параметры задавать поседними в списке параметров.

Это ограничение запрещает использовать одновременно необязательные параметры и модификатор `params` в одном методе

## Именованные параметры

Можно передавать значения параметров в метод беспорядочно, задав имя параметра, для которого задается значение

```csharp
int Square(int a, int b) => a * b;

var square1 = Square(b:50, a:4);
var square2 = Square(b:50, 3);
```

## Перегрузка методов

Разные методы могут иметь одно и то же имя, но разный состав параметров. Такие методы называются `перегрузками` и позволяют сделать вызов методов более удобным

Все перечисленные ниже перегрузки представляют разные версии одного метода:

```csharp
int Merge(int a, int b) => a + b;

int Merge(int a, int b, int c) => a + b + c;

string Merge(string a, string b) => a + b;

int Merge(ref int a, ref int b) => a + b;

int Merge(out int a, int b) => a + b;
```

Как видно и примера, перегрузки должны отличаться одним из следующих показателей:

- Количество параметров
- Типы параметров
- Наличие модификаторов `ref` или `out`

> Перегрузка метдов является проявлением **[[05 _ПОЛИМОРФИЗМ|ad-hoc полиморфизма]]**

## Рекурсия

> **Рекурсия** — это вызов метода внутри этого же метода

> **Глубиной рекурсии** называется количество вложенных вызовов рекурсивного метода

> Любая рекурсия может быть преобразована в цикл, обратное утверждение тоже верно

```csharp
// Рекурсивное вычисление факториала
int Factorial(int n)
{
    if (n == 1) return 1;
    return n * Factorial(n - 1);
}

int fact = Factorial(6);
```

```csharp
// Циклическое вычисление факториала
int Factorial(int n)
{
    int result = 1;
    for (int i = 2; i <= n; i++)
        result *= i;
    
    return result;
}
```

Хвостовая рекурсия — это разновидность рекурсии, при которой вызов метода из этого же метода является последним действием в методе

Хвостовые рекурсии могут быть оптимизированы, благодаря этому факту. Стек вызовов методов может быть минимальным (1 фрейм~), так как не нужно хранить контекст вышестоящего метода, потому что этот метод уже не будет выполнять никаких операций после

В .Net оптимизация хвостовой рекурсии в общем случае не выполняется. Иногда она может выполняться, но механизм оптимизации очень сложен и зависит от множества параметров, поэтому невозможно однозначно сказать, будет ли в том или ином случае реализована оптимизация.

## Возвращаемое значение

Возвращаемое значение можно получать по ссылке, что позволяет непосредственно менять состояние переменной без создания копий

```csharp
public ref int FindElement(int[] array, int index)
{
    if (index < 0 || index >= array.Length)
        throw new IndexOutOfRangeException();
    
    return ref array[index];
}

// Использование
int[] numbers = { 1, 2, 3 };
ref int element = ref FindElement(numbers, 1);
element = 42; // Изменяет numbers[1] на 42
```

При использовании `ref` важно помнить о безопасности. Возвращение ссылки на локальные переменные может привести к ошибкам и аварийному завершению программы, так как ссылка будет недействительна после выхода из метода

Использование `ref` может улучшить производительность, особенно при работе с большими [[01 Классы и структуры|структурами]]. Вместо создания копий больших объектов можно передавать ссылки на них, что снижает накладные расходы на память и ускоряет выполнение кода

В C# 12 был введен новый модификатор `ref readonly`, который позволяет более точно контролировать передачу параметров по ссылке без возможности их изменения. Это улучшает читаемость кода и уменьшает вероятность ошибок

```csharp
public struct ReadOnlyStruct
{
    public int Data;
}

public static ref readonly ReadOnlyStruct GetReadOnlyStruct()
{
    static ReadOnlyStruct myStruct = new ReadOnlyStruct { Data = 42 };
    return ref myStruct;
}

// Использование
var readOnlyData = GetReadOnlyStruct();
// readOnlyData.Data = 100; // Ошибка компиляции
```

> Если метод возвращает значение, то в каждом ответвлении кода метод должен возвращать значение или генерировать исключение (`throw new Exception()`). 

> Другими, словами, не может быть ситуаций, когда при выполнении метода будет достигнут участок кода после которого не будет возвращаться значение или генерироваться исключение

Вне контекста методов также можно использовать ссылки на переменные значимых типов

```csharp
int[] numbers = [0, 1, 2, 3];
ref int x = ref numbers[2]; // 2

x = 10; // numbers[2] == 10
```

Далее: [[02 Методы расширения|02 Методы расширения]]

#C-Sharp/Functions
Назад: [[05 Сопоставление с образцом|Сопоставление с образцом]]

**Делегат** — это набор указателей на методы. Выполнение делегата означает выполнение всех методов, на которые указывает делегат. При этом порядок выполнения методов неизвестен.

> Делегат не должен указывать на группу методов, котрые должны выполняться последовательно

Делегат — это класс в мире функций, у классов есть объекты, а у делегатов методы.

В системе .Net делегат — это класс `Delegate : Object`, предоставляющий необходимый интерфейс для взаимодействия с набором ссылок на методы

Создание делегатного типа:

```csharp
delegate double F(double x);

F function = Math.Sin; // без скобок
```

Обращаясь к методу без написания скобок, мы получаем ссылку на этот метод

## Лямбды

Как для примитивных типов, как для экземпляров класса, так и для делегатов можно использовать литералы.

**Лямбды** — это функциональные литералы, тип которых выводится по контексту, если этот тип не указан явно

Условно функциональные типы можно обозначать следующим образом:

```
(int, int) => int
//параметры => результат
```

Инициализация лямбдой:

```csharp
Action action = () => Console.WriteLine("Hello world");
```

Варианты синтаксиса лямбд:

* `() => 5`
* `x => 2*x`
* `(x) => 2*x`
* `(double x) => 2*x`
* `(x, y, z) => x + y - z`

```csharp
x => {
	Console.WriteLine("x is " + x);
    
    int Pow2(x, power)
    {
        for(int i = 0; i < power; i++)
            x *= x * 2;
        return x;
    }
    
    Console.WriteLine("f(x) is " + Pow2(x));
};
```

* Анонимная функция (устаревший синтаксис) — это аналог литерала:

```csharp
delegate(double x)
{
	return 2 * x * x - 3;
}
```

> Лямбды могут приводится к 2 типам: к делегатам и к абстрактным синтаксическим деревьям (AST)

При использовании `var` для инициализации делегата лямбдой обязательно нужно указывать тип явно.

Делегаты могут содержать ссылки на неограниченное количество однотипных методов (одно и тоже возвращаемое значение и список параметров с их типами).

>Стандарт .Net порядок вызова методов делегата не специфицирует. Вызов методов может происходить в порядке добавления, в случайном порядке, параллельно. Поэтому мультиделегаты обычно используются, если они не возвращают значение (void).

ЧТО ВОЗВРАЩАЕТ МУЛЬТИДЕЛЕГАТ С ВОЗВРАЩАЕМЫМ ЗНАЧЕНИЕМ?

Добавление методов в делегат происходит с помощью оператора +:

```csharp
delegate double Rfunction (double x);
Rfunction func = Math.Sin;
func = func + Math.Cos;
func += Math.Tan;
func -= Math.Sin; // удаление функции из делегата
```

>Если поместить в переменную делегата лямбду, то тогда невозможно будет удалить ее выборочно, так как ссылки на нее нет.  Придется удалять все данные, на которые указывает делегат.

## Методы делегатов

| Метод                 | Описание                                                          |
| --------------------- | ----------------------------------------------------------------- |
| `Combine()`           | добавляет метод в список вызова                                   |
| `Remove()`            | удаление метода из делегата                                       |
| `RemoveAll()`         | очистка делегата                                                  |
| `GetInvokationList()` | список делегатов, которые ссылаются на метод из текущего делегата |

## Замыкания

```csharp
Action Outer()  // метод или внешняя функция
{
    int x = 5;  // лексическое окружение - локальная переменная
    void Inner()    // локальная функция
    {
        x++;        // операции с лексическим окружением
        Console.WriteLine(x);
    }
    return Inner;   // возвращаем локальную функцию
}
//...

var fn = Outer;
fn(); //6
fn(); //7
fn(); //8
```

>Когда время жизни функции превосходит время жизни отдельных переменных, используемых внутри этой функции, то такие переменные захватываются функцией в специальный контекст. Этот механизм называется захват переменной или замыкание. Поэтому в любом ЯП с наличием функциональных типов содержится не только ссылки на функции, но и специальный контекст.

Далее: [[07 _Встроенные делегаты|Встроенные делегаты]]

#C-Sharp #C-Sharp/Functions/Delegates
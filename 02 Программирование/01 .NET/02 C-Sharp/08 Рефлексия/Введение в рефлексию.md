Интроспекция -- это возможность программы получать информацию о типах переменных и атрибутах объектов.

Рефлексия -- это способность компьютерной программы изучать (интроспекция) и модифицировать свою структуру и поведение (значения, метаданные, свойства и функции) во время выполнения.

Рефлексия более легко реализуема в интерпритируемых языках, так как~ определение типов происходит во время выполнения.

## Зачем нужна рефлексия

* Для тестирования программы
* Для серриализации и дессериализации объектов
* Для перевода объекта C# в JSON
* Для декомпиляции программы

>Рефлексия нужна там, где она нужна. Рефлексия -- дорогостоящий процесс.

Что может рефлексия:
1) Рефлексия позволяет работать с кодом программы как с данными
2) Работать с метаданными классов (конструкторы, методы, свойства...), методов и др.
3) Получать информацию о модификаторах доступа
4) Получить и установить значение поля объекта по имени

Преимущества | Недостатки
-|-
полный доступ над сущностями кода | низкая читабельность кода
__ | сложный процесс тестирования
__ | может значительно замедлить работу программы

# System.Reflection

Основной функционал рефлексии сосредоточен в пространстве имен System.Reflection.
Основные классы:
* Assembly -- класс, предоставляющий сборку
* MemberInfo -- абстрактный класс, представляющий член класса/структуры
* EventInfo -- событие
* FieldInfo -- поле
* MethodInfo -- метод
* PropertyInfo -- свойство
* ConstructonInfo -- конструктор
* ParameterInfo -- параметр метода
* Type -- тип

## Класс Type

System.Type представляет изучаемый тип и предоставляет доступ к членам этого типа.

### Методы

1) FindMembers() -- находит массив членов данного типа
2) GetConstructors() -- возвращает все конструкторы (ConstructorInfo)
3) GetEvents() -- возвращает все события
4) GetFields() -- возвращает все поля
5) GetMembers() -- возвращает все члены данного типа
6) GetMethods() -- возвращает все методы
7) GetProperties() -- возвращает все свойства
8) GetInterfaces() -- возвращает все реализуемые интерфейсы

* Существуют также аналогичные методы Get, которые возвращают одну сущность

Пример использования метода GetMethod:

```cs
Type t = typeof(String);

MethodInfo substr = t.GetMethod("Substring", new Type[]
	{
		typeof(int), //тип параметра функции
		typeof(int)
	});
```

### Свойства

1) Name -- имя типа
2) Assembly -- имя сборки, в которой определен тип
3) Namespace -- название пространства имен, где определен тип
4) IsArray -- проверяет, является ли тип массивом
5) IsClass -- проверяет, является ли тип классом
6) IsEnum -- проверяет, является ли тип перечислением
7) IsInterface -- проверяет, является ли тип интерфейсом
8) IsPrimitive -- проверяет, является ли тип базовым (int, string)
9) IsSealed -- проверяет, запечатан ли тип
10) IsValueType -- проверяет, является ли тип значимым

### Получение типа объекта

Получить тип объекта можно 3 способами:
1. оператор typeof()
2. object.GetType() -- метод класса object
3. Type.GetType() -- статический метод

```cs
var x = 5;
Type t = x.GetType();
Console.WriteLine(t); //System.Int32
```

* При вызове GetType у упакованных объектов, будет возвращен именно тот тип, которым упакованный объект является в действительности.

Метод Type.GetType:
Пусть имеется класс Person, который определен в глобальном пространстве имен программы.

```cs
Type? myType = Type.GetType("Person", false, true);
```

1-й параметр typeName -- полное имя класса с пространством имен (в данном случае пространство имен опущено, т.к. Person определен в глобальном пространстве имен программы);
2-й параметр throwOnError -- генерация исключения, если тип не найден;
3-й параметр ignoreCase -- игнорируется ли регистр.

Метод возвращает nullable Type?.

Если нужный нам тип находится в другой сборке dll, то после полного имени класса через запятую указывается имя сборки:

```cs
Type myType = Type.GetType("PeopleTypes.Person, MyLibrary",
						   false, true);
```

#C-Sharp #C-Sharp/Reflection
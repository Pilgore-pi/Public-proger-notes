
Классы могут перенимать черты от других классов, этот механизм называется **наследованием**. Наследование — это один из 3х главных принципов ООП. Данный механизм недоступен для структур.

Наследование помогает избежать избыточности кода, так как не приходится писать один и тот же код снова, если нам нужно использовать тот же класс, но с дополнительным свойством, например. Но самое главное — наследование позволяет создавать строгую неизменяемую архитектуру взаимосвязей между сущностями.

Простой пример наследования:

```csharp
// Базовый класс
public class Animal
{
    public string Name { get; set; }
    public void Eat()
    {
        Console.WriteLine("Eating...");
    }
}

// Производный класс
public class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine("Barking...");
    }
}
```

В этом примере `Dog` наследует от `Animal`. Это означает, что у `Dog` есть все свойства и методы `Animal`, плюс свои собственные.

>Можно запретить возможность наследования от данного класса, пометив его модификатором `sealed`. Такие классы называются **запечатанными**.
>Структуры, на самом деле являются запечатанными классами, которые компилятор пытается располагать на стеке.

### Оператор base (ссылка на базовый класс)

Ключевое слово `base` используется для обращения к членам базового класса из производного класса.

```csharp
public class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine($"{base.Name} is barking...");
    }
}
```

### Переопределение методов

Иногда необходимо изменить поведение метода базового класса в производном классе. Для этого используется ключевое слово `override`.

```csharp
public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("Some generic animal sound");
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark");
    }
}
```

### Абстрактные классы и методы

Абстрактный класс представляет собой нечто, что не является логически достаточно конкретным, чтобы существовать. Нельзя создать объект абстрактного класса. Аналогично существуют абстрактные методы и свойства. Вся идея использования абстрактных классов заключается в наследовании от них и реализации конкретной логики уже в производных классах.

```csharp
public abstract class Animal
{
    public abstract void MakeSound(); // нельзя определять реализацию
    
    // никакого скрытого поля не создается
    public abstract string Name { get; set; }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark");
    }
    private string name;
    public string Name => name;
}
```

### Интерфейсы

Интерфейсы определяют контракт, который должны соблюдать классы. Класс может реализовать несколько интерфейсов. Под контрактом подразумевается унифицированный набор возможностей как самого объекта, так и возможностей выполнять действия над объектом, выполняющий контракт.

Экземпляром интерфейса может быть только класс, который **реализует** интерфейс.

```csharp
public interface IAnimal
{
    void MakeSound();
}

public class Dog : IAnimal
{
    public void MakeSound()
    {
        Console.WriteLine("Bark");
    }
}
```

### Множественное наследование

В C# класс может наследоваться только от одного базового класса, но может реализовывать несколько интерфейсов.

```csharp
public interface IAnimal
{
    void MakeSound();
}

public interface IPet
{
    void Play();
}

public class Dog : IAnimal, IPet
{
    public void MakeSound()
    {
        Console.WriteLine("Bark");
    }

    public void Play()
    {
        Console.WriteLine("Playing...");
    }
}
```

## Отличия интерфейса от абстрактного класса


| Интерфейс                                                                     | Абстрактный класс                                                                         |
| ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Множественная реализация**. Класс может реализовывать множество интерфейсов | Класс может наследоваться только от одного абстрактного класса                            |
| Используется для определения контракта                                        | Используется для определения базового функционала, который может быть частично реализован |
| Не может содержать конструкторы                                               | Может содержать конструкторы                                                              |
| Не может содержать поля                                                       | Может содержать поля                                                                      |
| Не может иметь состояния                                                      | Может иметь состояние (поля)                                                              |
| Члены должны быть открытыми для доступа извне                                 | Члены могут иметь разный уровень доступа, в том числе и private                           |

**Итог**. Абстрактные классы уже могут содержать часть данных и структуры объекта, они используются, когда часто приходится использовать одно и тоже ядро. Интерфейс — это то, как сущность может взаимодействовать с миром, например, змея может видеть свет через интерфейс, называемый "зрение", чувствовать запахи через интерфейс "обоняние", питаться через интерфейс "челюсть". Интерфейс не имеет предопределенной логики и состояния, он просто требует, чтобы сущность могла определенным образом взаимодействовать с другими объектами. Можно считать, что интерфейс — это очень абстрактный класс, но никогда нельзя считать абстрактный класс интерфейсом.

#C-Sharp #OOP

СУБД FoxPro поддерживает SQL-подобный синтаксис для управления базами данных. SQL код можно писать прямо в коде модулей

# Файлы базы данных DBF и FPT

DBF файлы представляют собой SQL-подобную таблицу базы данных

- DBF файл может хранить до 10^9 записей
- Максимальный размер 1 записи: 65500 байт
- Максимальное число атрибутов записи: 255
- Максимальное допустимое число открытых файлов баз `.dbf`: 25 (стандартная версия) / 255 (расширенная версия)

В FoxPro активно используются *рабочие области*, области памяти, выделенные, обычно, для одной таблицы DBF. Обращение к рабочим областям происходит по их порядковому номеру (начиная с 0).

Нулевая рабочая область (с номером 0) -- это псевдоним для первой попавшейся пустой области. Эта область нужна, чтобы совершать переход на первую свободную область

> Чтобы получить имя таблицы DBF, расположенной в текущей рабочей области, можно воспользоваться функцией `DBF()`

> Работа с рабочими областями -- это небезопасное низкоуровневое управление памятью. При работе с рабочими областями, разрабочик должен хорошо понимать, что он делает

Типы и размеры полей:

| Тип | Размер в байтах | TYPE() | Описание |
|-|-|-|-|
| CHARACTER | до 254 | `'С'` | символный тип |
| NUMERIC / FLOAT | до 20 | `'N'`, `'F'` | число с плавающей точкой |
| DATE | 8 | `'D'` | дата |
| LOGICAL | 1 | `'L'` | булево |

### Получение количества записей

Системная переменная `_TALLY` содержит число записей в активной таблице БД, которые были обработаны командами:

- `APPEND FROM`
- `SELECT`
- `SORT`
- `SUM`
- `AVERAGE`
- `CALCULATE`
- `COPY TO`
- `COUNT`
- `DELETE`
- `INDEX`
- `REINDEX`
- `REPLACE`
- `JOIN`
- `PACK`
- `TOTAL`
- `UPDATE`

При старте программы, переменная `_tally` инициализируется в `0`

# Операции над таблицами БД

## Создание файла таблицы БД (DBF)

SQL:

```sql
CREATE DBF <dbf>
    (<имя_поля> <тип> [(<размер>[, <дробных_разрядов>])
    [, <имя_поля> <тип> [(<размер>[, <дробных_разрядов>]) ...]
    / FROM ARRAY <двумерный_массив>
```

Параметр `тип`:

- `C(n)`: CHARACTER
- `N(n)`: NUMERIC
- `D`: DATE
- `M`: MEMO (файл примечаний, хранящий информацию о ссылках на файлы, то есть, поля MEMO)
- `F(n)`: FLOAT
- `L`: LOGICAL

FoxBase:

```foxpro
CREATE kadr          && Создание файла kard.dbf в активной директории
CREATE d:\kadr\kadr  && Создание файла по абсолютному пути
```

## Модификация структуры таблицы

Выполняется командой `MODIFY`. Для данной операции требуется эксклюзивный доступ

```foxpro
MODIFY STRUCTURE
```

## Открытие таблицы

```foxpro
USE <dbf_file>
    [IN <рабочая_область>]     && по умолчанию текущая рабочая область
    [ALIAS <псевдоним>]
    [AGAIN]                    && разрешено открытие таблицы еще раз (даже если таблица уже открыта)
    [SHARED]                   && делает доступным таблицу БД всем пользователям, даже, если таблица открыта эксклюзивно
    [EXCLUSIVE]                && открывает таблицу в режиме эксклюзивного доступа
    [NOUPTDATE]                && открытие в режиме "только для чтения"
    [INDEX <список_индексов>   && список используемых индексов
        [ORDER [<номер_индекса> | <idx_file> | [TAG] <имя_тега> [OF <cdx_file>] [ASCENDING | DESCENDING]]]]
```

Порядок перечисления индексов в подкоманде `Index` важен. Первый в списке индекс будет считаться **главным**

Подробнее об [[05 Индексы|индексах]]

При выполнении команды USE повторно, в текущей рабочей области закрываются все таблицы БД и открывается указанная таблица

```foxpro
USE example
```

### Команда `SET EXCLUSIVE`

Глобально задает режим открытия всех таблиц в `EXCLUSIVE`. Выполнение команды не влияет на уже открытые таблицы

```foxpro
set exclusive on   && По умолчанию ON
set exclusive off
```

Режим эксклюзивности открывает полный доступ к DBF только тому, кто открыл эту таблицу, остальные пользователи не могут делать записи и даже читать данные

## Закрытие таблиц и освобождение ресурсов

**Команда `CLOSE`** закрывает используемый файл, что делает его доступным для использования другими приложениями, а также, необходимо закрывать файлы, чтобы можно было их повторно использовать в программах FoxPro

| Команда | Описание |
|-|-|
| `CLOSE ALL` | Закрывает все файлы и все рабочие области, и выбирает рабочую область `1`. Также закрывает все файлы, открытые с помощью `FOPEN()`, `FCREATE()` |
| `CLOSE ALTERNATE` | Закрывает альтернативный файл, открытый с помощью команды `SET ALTERNATE` |
| `CLOSE DATABASES` | Закрывает все таблицы, рабочие области, индексы и форматы |
| `CLOSE INDEXES` | Закрывает все индексы (IDX, CDX), кроме составного индекса с именем, совпадающем с именем открытой таблицы |
| `CLOSE FORMAT` | Закрывает файл формата текущей рабочей области |
| `CLOSE PROCEDURE` | Закрывает файл, открытый через `SET PROCEDURE` |

**Команда `CLEAR`**

| Команда | Описание |
|-|-|
| `CLEAR` | Очищает "рабочий стол" FoxPro или окно, определенное пользователем. Освобождает все операторы `@ ... GETS` |
| `CLEAR ALL` | Очищает все пользовательские переменные, открытые таблицы с рабочими областями, окна, меню и задает в качестве текущей рабочей области область `1` |
| `CLEAR FIELDS` | Освобождает память, выделенную командой `SET FIELDS` и выполняет `SET FIELDS OFF`|
| `CLEAR GETS` | Освобождает все операторы `@ ... GETS` |
| `CLEAR MACROS` | Очищает все макросы клавиатуры из памяти |
| `CLEAR MEMORY` | Очищает все `PUBLIC` и `PRIVATE` переменные |
| `CLEAR MENUS` | Освобождает память, в которой храняться данные меню |
| `CLEAR POPUPS` | Освобождает память элементов `POPUP` |
| `CLEAR PROGRAM` | Очищает буфер, в котором храниться скомпилированная программа. Данная команда полезна, в случаях, когда FoxPro игнорирует изменения в файле с исходным кодом и продолжает использовать устаревшую скомпилированную версию программы. **Однако**, может потребоваться отключить модуль с программой и заново подключить, чтобы гарантированно получить актуальную версию программы |
| `CLEAR PROMPT` | Освобождает все операторы `@ ... PROMPT` |
| `CLEAR READ [ALL]` | Закрывает текущее READ окно и переходит на 1 уровень вверх к другому окну READ, если окна вложены (допустимо макс. 5 уровней). Окно Read может не сразу закрыться, при этом будет доступен ввод и обработка данных |
| `CLEAR TYPEHEAD` | Очищает буфер предварительного ввода клавиатуры\* |
| `CLEAR WINDOWS` | Закрывает все пользовательские окна |

Буфер предварительного ввода -- это область памяти, куда попадает информация о нажатых клавишах, которые еще не были обработаны. К примеру, при загрузке интерфейса пользователь может случайно нажать несколько клавиш еще до того, как интерфейс прогрузиться. Поэтому, чтобы не терять эти нажатия клавиш, они сохраняются в буфере для последующей обработки, когда интерфейс будет сгенерирован 

## Выборка данных

> После создания и модификации структуры таблицы, она остается открытой, в противном случае нужно использовать команду `USE`, чтобы открыть файл `.dbf`

SQL:

```sql
SELECT 
	[ALL | DISTINCT]
[<alias>.]<select_item> 
	[AS <column_name>]
	[, [<alias>.]<select_item> 
		[AS <column_name>] ...] 
FROM <table> 
	[<local_alias>] 
	[, <table> [<local_alias>] ...] 
	[[INTO <destination>] | 
	[TO FILE <file> [ADDITIVE] | TO PRINTER [PROMPT] | TO SCREEN]]
	[PREFERENCE <name>]
	[NOCONSOLE]
	[PLAIN]
	[NOWAIT]
	[WHERE <joincondition> [AND <joincondition> ...] 
	[AND | OR <filtercondition> [AND | OR <filtercondition> ...]]]
	[GROUP BY <groupcolumn>[, <groupcolumn> ...]]
	[HAVING <filtercondition>]
	[UNION [ALL] <SELECT command>]
	[ORDER BY <order_item> [ASC | DESC] [, <order_item> [ASC | DESC] ...]]

// Синтаксис 1 поля
[<псевдоним>.]<выражение> [AS <колонка>]

// Синтаксис подкоманды INTO
INTO <приемник>
INTO ARRAY <массив>
INTO CURSOR <курсор>
INTO TABLE <dbf_файл>
```

> Подкоманда `INTO` создает новый объект (курсор, DBF, массив...), даже если он уже был объявлен ранее

> Если не указать подкоманду INTO, то результат выборки будет отображен в окне `BROWSE`. При этом нельзя будет обратиться к данным такой выборки в коде, так как никакая рабочая область не выделяется

> **Курсор** -- это временная таблица, хранящая результат запроса. Курсор храниться только в оперативной памяти, в отличие, от таблицы DBF, сохраняемой на диске. По умолчанию курсоры открываются в режиме "только для чтения"

> Объявленный курсор или DBF таблица при выполнении запроса доступны глобально, то есть, вне текущей процедуры или функции или модуля


FoxPro:

```foxpro
SELECT <номер_рабочей_области> | <псевдоним_таблицы>
```

Данная команда не является SQL командой `select`. Эта команда выполняет переход на указанную рабочую область. Если указано имя таблицы, то будет выполнен переход на ту область, в которой эта таблица была использована с помощью команды `USE`

Примеры запросов

```foxpro
** [SQL-like] Выбор всех записей таблицы (только указанные 3 столбца)
** Создание двумерного массива в который записывается результат запроса
select skl, uch, fio from cRaspred into array tempArray

** [SQL-like] выбор всех записей и всех столбцов таблицы
select * from goods

** [FoxPro] НЕ-SQL оператор, который выполняет переход на указанную рабочую область
select 99

** Переход на пустую рабочую область
select 0

** Переход на рабочую область, где находится указанная таблица
select dbfName
```

При выполнении запроса select в командном окне FoxPro, будет отображено окно BROWSE с результатом запроса

Представленный синтаксис команды SELECT является неполным (описаны основные параметры). В FoxPro эта команда представляет полноценный аналог команды SQL Select и имеет дополнительные параметры, (например `nowait`, `noconsole`, `plain`, ...)


### Что лучше использовать в данной версии Fox, оператор SQL Select или scan для достижения наибольшей производительности?

Для FoxPro 2.6 вопрос производительности между использованием SQL SELECT и циклом SCAN зависит от конкретной задачи и структуры данных, но есть несколько важных моментов:

- **SQL SELECT** в FoxPro 2.6 обычно использует индексы и оптимизирован для выборки данных, особенно если запросы простые и фильтрация совпадает с индексами. SELECT быстрее и удобнее при выборке большого объема данных с условиями и сортировкой, так как движок FoxPro оптимизирует такие запросы[^2].
- **SCAN** - это процедурный способ перебора записей таблицы в коде FoxPro. Он даёт полный контроль над обработкой каждой записи, но при большом объеме данных и сложной логике может работать медленнее, чем оптимизированный SQL-запрос. SCAN полезен, если нужно выполнить сложную логику, которую в SQL выразить сложно или невозможно[^2].
- По результатам обсуждений и тестов пользователей FoxPro, при простых условиях поиска и наличии индексов SELECT и SEEK/LOCATE работают примерно с одинаковой скоростью. При этом время выполнения SELECT обычно стабильно, а SCAN зависит от количества записей и позиции курсора[^2].
- Если задача сводится к выборке с простыми условиями и агрегацией, лучше использовать SQL SELECT - это более декларативный и оптимизированный способ.
- Если требуется сложная постобработка записей, фильтрация с нестандартной логикой или изменение данных в процессе прохода, SCAN будет удобнее, хотя и может быть менее производительным.

**Вывод:**
Для достижения наибольшей производительности в FoxPro 2.6 при выборке данных с условиями и агрегацией предпочтительнее использовать оператор SQL SELECT, особенно если условия совпадают с индексами таблиц. SCAN целесообразен для сложной логики обработки, но обычно медленнее при больших объемах данных[^2][^3].

Если нужна максимальная скорость выборки - нужно делать упор на правильное индексирование и использование SQL SELECT. Если нужна сложная логика - SCAN с DO CASE.

---

<div style="text-align: center">⁂</div>

[^1]: https://forum.ixbt.com/topic.cgi?id=40%3A466

[^2]: https://forum.foxclub.ru/read.php?29%2C422225

[^3]: https://help.foxclub.ru/html/822ef7c0-0c8e-43b8-ba98-5a4246a94c59.htm

[^4]: https://stackoverflow.com/questions/50937678/foxpro-append-arbitrary-number-of-views-into-a-single-view-or-table

[^5]: https://elar.rsvpu.ru/bitstream/123456789/26906/1/foxpro2x_2000.pdf

[^6]: https://books.4nmv.ru/books/samouchitel_visual_foxpro_90_3642744.pdf

[^7]: https://www.samsmu.ru/files/smu/chairs/radiology/med_inf.pdf

[^8]: https://kuzstu.ru/web-content/sitecontent/sveden/education/SPO/Info_ob_OP/2024/10.02.15_2024/10.02.05_PM.01_2024.signed.pdf



## Вставка данных

SQL:

```sql
INSERT INTO <table> [(<поля>)] VALUES (<выражение1>[, <выражение2>...])

INSERT INTO <table> {ARRAY <array>} | {FROM MEMVAR}
```

FoxBase (Добавление записей из указанного источника):

```foxpro
APPEND FROM <файл_источник> [FIELDS <поля>]
    [FOR <условие>]
    [WHILE <условие>]
    [[TYPE] <тип_файла>] && по умолчанию DBF
```

Явное указание выбираемых полей позволяет заполнять таблицу данными из источника с другой структурой

Вставляет записи в конец таблицы БД

## Модификация данных

SQL:

```sql
UPDATE ON <поле_ключа> FROM <область>
    REPLACE <поле> WITH <выражение>
    [, REPLACE <поле> WITH <выражение> ...]
    [RANDOM]
```

FoxBase:

```foxpro
REPLACE [<границы>] [WHILE <условие>] [FOR <условие>]
    <поле> WITH <выражение>
    [,<поле> WITH <выражение> ...]
    [ADDITIVE]
    [NOOPTIMIZE]
```

Пример FoxBase:
```foxpro
replace ;
    nc_pol with IIF(found, d2221.nc_pol, 'noORM'), ;
    nc_vip with IIF(found, d2221.nc_vip, 'noORM')
```


## Удаление данных

| Команда удаления | Описание |
|-|-|
| `ERASE <file> / DELETE FILE <file>` | Удаление любого не открытого в даннный момент файла |
| `ZAP` | Удаление всех записей в активном файле базы данных с сохранением его структуры |
| `DELETE [<границы>] [WHILE <условие>] [FOR <условие>]` | Пометка на удаление указанных записей согласно указанным условиям. DELETE без параметров помечает на удаление одну текущую запись таблицы |
| `PACK [MEMO] [DBF]` | физическое удаление помеченных записей и сжатие файла. Открытые индексы перестраиваются. Если указано `MEMO`, то будет упаковываться только FPT файл, если `DBF`, то только DBF |
| `RECALL [<границы>] [WHILE <условие>] [FOR <условие>]` | Снимает пометки на удаление. `RECALL` без параметров действует только на текущую запись |

Упаковка MEMO полей может быть полезна, если эти поля часто используются и редактируются, так как при уменьшении объема хранимых данных в MEMO-поле, его физический размер остается прежним, если не выполнять упаковку

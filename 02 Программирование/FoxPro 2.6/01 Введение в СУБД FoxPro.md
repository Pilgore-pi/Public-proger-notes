
# СУБД FoxPro

[Документация по Visual FoxPro](https://www.vfphelp.com/help/index.htm)

[Документация firststeps](https://firststeps.ru/foxpro/helpfox/helpfox1.html)

Ограничения версии 2.6

- ООП не поддерживается
- COM не поддерживается
- Сетевые протоколы не поддерживается (хотя удаленное подключение к базе доступно)
- Внешние DLL не поддерживаются, но возможен запуск внешних программ (`RUN`)
- Импорт кода очень ограничен. Поддерживается только язык FoxPro и только 1 файл одновременно
- Не поддерживается в современных ОС
- Невозможно использовать файлы и каталоги, чьи имена более 8 символов или чьи расширения более 3 символов
- Наименования переменных не могут быть длиннее 10 символов
- Ограниченные возможности функций (например, нельзя вернуть массив)
- В FoxPro 2.6 существует ограничение на максимальную длину строки исходного кода - одна строка не может превышать примерно 8 192 байта (8 КБ). Это ограничение касается как обычных строк кода, так и строковых литералов, SQL-запросов и макроподстановок. Если при компиляции или сборке проекта компилятор встречает строку, превышающую этот лимит, появляется ошибка line is too long

## Язык FoxBase

### Общая структура команды FoxBase

```
НАЗВАНИЕ            - Название команды
    <границы>       - Область действия команды. Границы могут принимать следующие значения:
        ALL         - Все записи таблицы БД
        REST        - Все записи, начиная с текущей и до конца
        NEXT <N>    - Следующие N записей (начиная с текущей)
        RECORD <N>  - Запись с порядковым номером N
    FOR <условие1>   - Выполнение команды только для записей, отвечающих условию 1
    WHILE <условие2> - Выполнение команды только до тех пор, пока условие 2 истинно
```

[[Встроенные команды|Список встроенных команд]]

### Ввод-вывод

Вывод

```foxpro
* Вывод текстового представления любого выражения в главной рабочей области
? [<выражение1> [PICTURE <картинка>] [FUNCTION <функция>]]
   [AT <выражениеN>] [, <выражение2>...]

* Команда ?? выполняет вывод в текущей строке и текущем столбце 

* Вывод текста с переводом на следующую строку в главной рабочей области   *
* Все, что идет после `\` воспринимается как текст                         *
\ текст

* Аналогично команде '\', но без перевода на след. строку                  *
\\ текст
```

Ввод

```foxpro
input "Enter A " to a
input "Enter B " to b
```

### Переменные

> Любые идентификаторы переменных, функций, процедур и модулей не должны превышать 10 символов. Если идентификатор содержит больше 10 символов, то остальные символы, начиная с 11-го, будут проигнорированы. Использование длинных идентификаторов может быть оправдано только для повышения читаемости кода

#### Литералы

| Литерал | Описание |
|-|-|
| `'текст'` | Строка (Character) |
| `"текст"` | Строка (Character) |
| `12`, `12.1` | Число (Numeric, Float) |
| `.t.`, `.T.` | Булево `true` (Logical) |
| `.f.`. `.F.` | Булево `false` (Logical) |

Литерала пустой ссылки (`NULL`) нет в FoxPro 2.6, но, фактически, переменные могут принимать такое значение 

#### Функция EMPTY()

```foxpro
EMPTY("")        && .t. 
EMPTY('      ')  && .t.
EMPTY(CTOD(''))  && .t. ; Null, пустая дата
EMPTY(0)         && .t.
EMPTY(.f.)       && .t.
EMPTY(<MEMO>)    && .t. , если поле пустое
EMPTY(<GENERAL>) && .t. , если нет объекта OLE (пустое значение)

EMPTY("_")       && .f.
EMPTY(-1)        && .f.
EMPTY(.t.)       && .f.
```

Создание нескольких переменных с одним значением:

```foxpro
var1 = .t.
var2 = .t.
var3 = .t.

** ИЛИ

store .t. to var1, var2, var3
```

Если переменная до этого не была определена, то оператор присваивания (`STORE` / `=`) создает эту переменную

Оператор присваивания можно применить как к массиву в целом, так и к его элементам:

```foxpro
dimension arr[10]
arr = '#'             && все элементы инициализированы одним значением '#'
store 5 to d[1], d[2] && первые 2 элемента имеют значение 5
```

#### Переменные памяти

Переменные с префиксом `m.` в FoxPro обозначают **переменные памяти** (memory variables). Этот префикс служит для явного указания, что речь идет именно о переменной памяти, а не о поле таблицы.

По умолчанию, если в коде используется имя без префикса, FoxPro сначала пытается найти поле с таким именем в текущей открытой таблице. Если поля нет, тогда ищет переменную памяти. Использование m. убирает неоднозначность и явно говорит, что это именно переменная памяти.

Кроме того, префикс `m.` повышает читаемость кода и немного ускоряет операции чтения переменных, так как FoxPro сразу обращается к памяти, минуя поиск по структурам таблиц.

#### Операторы

| Оператор | Значение |
|-|-|
| `=` | Присваивание значения |
| `+` | Сложение |
| `-` | Разность |
| `*` | Произведение |
| `**`, `^` | Возведение в степень|
| `%` | Остаток от деления |
| `/` | Деление |

| Логический оператор | Значение |
|-|-|
| `>` | Больше |
| `>=` | Больше или равно |
| `<` | Меньше |
| `<=` | Меньше или равно |
| `#`, `!=`, `<>` | Неравенство |
| `=` | Равенство выражений |
| `==` | Равенство строк |
| `!`, `NOT` | Логическое отрицание |
| `AND` | Логическое И |
| `OR` | Логическое ИЛИ |
| `$` | Строка содержит (string $ substring) |


#### Глобальные переменные

Храняться на уровне всей СУБД, даже если модуль, который послужил причиной создания этих переменных, удален

Объявление глобальных переменных:

```foxpro
PUBLIC <переменные> [, <массивы переменных>]
```

Пример:

```foxpro
PUBLIC A, B, R(10), Z(2,6)
```

В примере объявляются глобальные переменные A, B и массивы R и Z. Применение команды DIMENSION для объявления этих массивов не требуется

При объявлении переменных в командном окне, они также являются глобальными

### Коллекции

- В FoxPro 2.6 существует только 1 тип коллекций -- массив.
- Перечисление элементов массива начинается с 1
- Массивы могут быть одномерными и двумерными (но не другими)
- Длину массива можно получить с помощью специальной функции `ALEN(arr, [dimension])`

Объявление массива

```foxpro
DIMENSION myArray(3)  && объявление одномерного массива на 5 элементов
DECLARE   myArray(3, 8) && Объявление двумерного массива
DIMENSION myArray[3, 9] && можно использовать квадратные скобки

PUBLIC myArray[2,6]     && Объявление глобального массива
```

Обращение к элементам массива:

```foxpro
myArray[1] = 'one'
myArray(2) = 2
myArray[3] = .t.

? myArray[1] && one
? myArray[2] && 2
? myArray(3) && .T.

dimension my2DArray[2,3]

my2DArray[1,1] = "1a"
my2DArray[1,2] = "1b"
my2DArray[1,3] = "1c"
my2DArray[2,1] = "2a"
my2DArray[2,2] = "2b"
my2DArray[2,3] = "2c"

```

К элементам двумерных массивов можно обращаться как по одному индексу, так и по двум (строка + столбец)

Тип каждого элемента массива определяется последней операцией присваивания (`=`, `store`, `scatter`)

> Можно изменить измерения массива, заново объявив его через оператор DIMENSION

Массивы хранят 1 переменную с именем массива. Максимальное количество элементов:

- 3600 для стандартных массивов
- 65000 для расширенных массивов

#### Операции с массивами

**Команды:**

1. `declare` / `dimension`:
2. `scatter`: заполняет одномерный массив или переменную данными, полученными из активной записи таблицы БД
3. `gather from`: изменяет текущую запись БД данными из массива
4. `copy to array`: заполняет двумерный массив записями из текущей таблицы БД
5. `append from array`: добавляет новые записи в таблицу, полученные из двумерного массива
6. `replace from array`: изменяет существующие записи таблицы БД данными, полученными из двумерного массива

```foxpro
SCATTER [FIELDS <поля>] [MEMO]        
    TO <массив> / TO <массив> BLANK / BLANK / MEMVAR BLANK

GATHER FROM <массив> / MEMVAR
    [FIELDS <поля>] [MEMO]

COPY TO ARRAY <массив>
    [FIELDS <поля> [<границы>]]
    [FOR <условие>] [WHILE <условие>]

APPEND FROM ARRAY <массив>
    [FOR <условие>] [FIELDS <поля>]

REPLACE FROM ARRAY <массив>
    [<границы>] [FIELDS <поля>]
    [FOR <условие1>] [WHILE <условие2>]
```

**Функции:**

- `aLen(массив[, измерение])`: возвращает длину массива. `измерение = {0, 1, 2}`, 0 - по умолчанию, 1 - число строк, 2 - число столбцов
- `aElement(массив, строка[, столбец])`: возвращает одномерный номер элемента двумерного массива по номеру строки и столбца. Номер $L$ элемента $A_{i,j}$ массива размерности $A(K,N)$ вычисляется по формуле $L=N\times (i-1) + j$
- `aSubscript(массив, абсолютный_номер_элемента, <флаг>)`: флаг может принимать 1 (будет возвращен номер строки) и 2 (будет возвращен номер столбца)
- `aDel(массив, номер_элемента[, 2])`: выразает элемент из массива или строка/столбец из двумерного массива
- `aIns(массив, номер_элемента[, 2])`: вставляет элемент в указанной позиции
- `aCopy(массив1, массив2[, позиция_начала_в_1_массиве[, число_элементов[, позиция_начала_во_2_массиве]]])`: копирует элементы из массива в другой массив, если второго массива не существует, он будет создан
- `aScan()`
- `aSort()`
- `aFields(массив)`: копирует таблицу БД в двумерный массив, возвращает число столбцов. Массив содержит столько же элементов, сколько и строк в таблице
- 

#### Области видимости переменных

**Локальные** переменные существуют только в области видимости модуля, в котором они объявлены и во всех подчиненных модулях

```foxpro
PRIVATE <переменные>
```

Можно присвоить признак локальности к группе переменных, без их поименного перечисления

```foxpro
PRIVATE ALL LIKE <маска>
PRIVATE ALL EXCEPT <маска>
```

Глобальные переменные:

```foxpro
PUBLIC A, B, ARR(25), MAT[90,4]
```

Глобальные переменные должны быть объявлены до любого обращения к ним, даже если обращение происходит из других модулей. По этой причине, при разработке форм, следует объявлять глобальные переменные в модуле *Screen setup code*, так как при объявлении в модуле *Cleanup and procedures*, функции и процедуры, обращающиеся к этим данным могут быть определены раньше (в модуле Setup code)

#### Типы переменных

Тип любого выражения можно получить с помощью функции `TYPE()`, функция на вход принимает вычисляемое выражение, заключенное в кавычках

### Условия

```foxpro
if var1 > 10
    ** code
[else]
    [**code]
endif

do case
case ch = 1
    ** code
case ch = 2
    ** code
otherwise
    ** code
endcase
```

### Циклы

```foxpro
for i = 1 to 5
    ** code
endfor

for i = 1 to 500 step 10
    ** code
next   && тоже самое, что и endfor

do while .t.
    ** code
enddo
```

**`EXIT`** -- прерывает выполнение цикла и продолжает выполнение следующего за `enddo` кода

**`LOOP`** -- прерывает выполнение текущей итерации цикла и переходит к следующей

### Процедуры и функции

> По умолчанию, переменные и массивы посылаются в процедуры по ссылке

#### Процедуры

```foxpro
procedure myProcedure
    ** код процедуры
return

** Процедуры с параметрами

procedure myProcedure
   PARAMETERS Par1, Par2, Par3
   ** код процедуры
return

** ИЛИ

PROCEDURE myProcedure(Par1, Par2, Par3)
    ** код процедуры
RETURN
```

Процедуры завершаются одним из следующих образов:

- Достижением последней команды в процедуре
- Командой `RETURN`, которая прерывает выполнение процедуры и передает управление вызываемому коду
- Командой `CANCEL`, которая выполняет выход на *командный уровень*
- Командой `QUIT`, которая выполняет выход из СУБД FoxPro

Команда RETURN позволяет управлять уровнем, на который будет выполнен возврат из процедуры. Можно перейти на любую процедуру:

```
RETURN             - стандартное завершение процедуры
RETURN TO MASTER   - выход на самый верхний уровень вызывающих процедур
RETURN <процедура> - выход на процедуру с указанным именем
RETURN <выражение> - возврат значения из функции
```

Вызов процедуры

Синтаксис:

```foxpro
DO myProc [WITH <parameter-list>] [IN <source-file-path>]
```

Если не указано расширение внешнего файла, содержащего код процедуры, то СУБД ищет процедуру сначала в `.exe` файлах, затем в `.app`, `.fxp`, `.prg`, соответственно.

Вызов процедуры как функции:

```foxpro
=myProc(<param-list>)
```

Можно явно проверить, какие параметры были переданы

```foxpro
myVar = 4
myVar2 = 5
DO myProcedure WITH myVar, myVar2
```

Передача парамтеров в процедуру по значению

```foxpro
myVar = 4
myVar2 = 5
DO myProcedure WITH (myVar), (myVar2)
```

#### Модули

Модули можно рассматривать как большие процедуры, которые могут содержать в себе глобальные языковые конструкции, процедуры и функции.
Обращение к модулям происходит также как и к процедурам.

Определение модуля с параметрами:

```foxpro
parameters par1, par2, par3, ...
    ** Код модуля и объявления процедур и фукнций
```

**Подключение модуля:**

```foxpro
SET PROCEDURE TO C:\FOLDER\MODULE.PRG  && импорт файла с кодом
SET PROCEDURE TO                       && откючение файла
```

> Единовременно может быть подключен **только один** файл с кодом

> Максимальный уровень вложенности кода -- 32 уровня. Например, если из стартовой программы, была вызвана процедура, в которой была вызвана функция, то здесь уровень вложенности будет 3 

#### Процедуры-Функции (ПФ)

> По умолчанию, переменные и **массивы** передаются в определенные пользователем функции по значению, поэтому нужно явно задавать `UDFPARMS` в `REFERENCE`, если необходимо передать массив

Если передать массив по ссылке в фукнцию, то будет передан только его первый элемент, что не соответствует ожидаемому типу данных

Можно явно задать, что параметры передаются по значению таким образом:

```foxpro
SET UDFPARMS TO VALUE
```

Поэтому, изменения, произведенные в функции над посланными переменными или массивами не возвращаются назад вызывающей программе

```foxpro
function MyFunc
return "Результат функции"

** Функция с параметрами

function MyFunc
parameters a, b
return IIF (a > b, a, b)
```

> В некоторых случаях можно обойтись без оператора `RETURN` в функции. А иногда, можно не писать оператор `return` только в конце кода функции (например, если функция последняя в файле и за ней не идет никакого кода)

Вызов

```foxpro
myFunction11(myVar, myVar2)
=myFunction2()
```

Если функция определена во внешнем модуле, то нужно указать путь к файлу с кодом таким образом:

```foxpro
set procedure to C:\MyPrjs\test\prgs\test.prg  ** это пример
myFunction('123', 0.123)
```

> Функции могут возвращать только примитивные типы (например, массивы функции возвращать не могут). Это ограничение можно обойти, если передавать массив по ссылке в функцию и заполнять его внутри функции. Тогда можно вообще использовать не функцию а процедуру с выходными параметрами

> **Имена файлов и каталогов должны быть не более 8 символов, в противном случае СУБД просто проигнорирует эти файлы (для версии FoxPro 2.6 и ниже)**

Вызов с передачей параметров по ссылке

```foxpro
SET UDFPARMS TO REFERENCE
=myFunction(myVar, myVar2)
```

### Встроенные функции

#### Дата

```foxpro
? date() && This command shows the system date.

? time() && This command shows the system time

? cdow(date()) && This will show the current Day name.

? month(date()) && This will show the month’s number.

? year(date()) && This will show the current year.

? DBF() && This will show the current opened database file name.

? version() && This will show the version of the FoxPro database system.

? OS() && This will show the DOS Operating System version.
```

#### Текст

```foxpro
a=”NCIT Technology”

? len(a) && This will show the length of the string 'a'.
Answer: 15

? left(a,3) && This shows the 3 letters of the string from the left side.
Answer: NCI

? right(a,3) && This shows the 3 letters of the string from the right side.
Answer:ogy

? substr(a,6,12) && This will show the string from the middle by given location. It will start from the 6 letter to the 12th letter.
Answer: Techno

?upper(a) && This will convert the string to the uppercase letters.
Answer:NCIT TECHNOLOGY

?lower(a) && This will convert the string to the lower letters.
Answer: ncit technology

?proper(a) && This will convert the string to the suitable case.
Ncit technology

?at(“Tech”,a) && This function will returns the position of the given word from the string. 
Answer: 6

? stuff(a,6,15,”Devigarh”) && This command replace the text on the given location and enter the new text.
Answer: NCIT Devigarh
The function Technology with Devigarh
```

## Команда `RUN`

FoxPro позволяет запускать внешние программы, и обращаться к переменным **`PATH`**

```foxpro
!DEL *.txt>NUL

* ИЛИ

RUN DEL *.txt>NUL
```

Здесь вызывается программа, которая удаляет все файлы, соответствующие маске, вывод системных сообщений отключен

### Перемещения в базе данных

Цикл сканирования таблицы БД:

```foxpro
scan [<границы>]
    [for <условие>]    && фильтр по полям
    [while <условие>]  && условие, только при соблюдении которого выполняется цикл
    ** code
endscan

** Аналогично

do while !EOF()
    ** code
    skip       && ручное управление указателем на запись в таблице, инкремент указателя
enddo
```

При отсутсвии ограничивающих условий, таблица БД сканируется полностью

> **После** выполнения тела блока `scan`, указатель перемещается на следующую запись таблицы

`continue` продолжает поиск записей, который был инициирован ранее

Команды перемещения:

- `GO TOP [IN <область>]`: переход к первой записи
- `GO BOTTOM [IN <область>]`: переход к последней записи
- `GO <номер_записи> [IN <область>]`: переход к записи с указанным номером
- `LOCATE [<границы>] FOR <условие> [WHILE <условие>]`: выполняет поиск первого вхождения записи, удовлетворяющей условию
- `SKIP [<число_записей> [IN <область>]]`: переход к записи, отстоящей от текущей на указанное число записей (по умол. +1)

* *При использовании индекса, команда `skip` перемещает указатель в соответствии с этим индексом*

- `RECNO([область])`: возвращает номер текущей записи
- `RECCOUNT([область])`: возвращает число всех записей в таблице, даже тех, которые помечены на удаление
- `EOF([область])`: определяет, был ли достигнут конец файла
- `BOF([область])`: определяет, было ли достигнуто начало файла

`область` -- рабочая область, относительно которой выполняется команда

#FoxPro

MVVM (Model-View-ViewModel) — шаблон проектирования многоуровневой архитектуры приложения, который заключается в разделении логики программы и ее интерфейса. MVVM принадлежит семейству MV-паттернов. Другие MV-паттерны: MVC, HMVC, MVP. Платформы ориентированные под паттерн MVVM: WPF, Avalonia, UWP, Xamarin, MAUI.

Приложение разделяется на 3 компонента

1. **View (представление)** — графический интерфейс и несложная логика отображения интерактивных элементов (XAML, MainWindow.cs, MainPage.cs и другой код интерфейса). View должен быть максимально "глупым" и быть полностью независимым от внутренней реализации других уровней.
2. **Model (модель)** — логика работы с данными и описание структур данных (классов, иерархий типов, пользовательских типов данных), взаимодействие с API, с БД, разработка мат. модели и алгоритмов работы с определенными на этом уровне структурами.
3. **View Model (модель представления)** — прослойка между Model & View, обеспечивающая связь между View и Model. Содержит в себе бизнес-логику приложения, необходимую для подготовки данных для отображения во View, а также обрабатывает события Model и View, и обрабатывает обновление данных в UI при изменении данных из Model с помощью привязки данных.

>**Модель** и **представление** полностью независимы

>**Представление** взаимодействует с данными опосредовано через **модель представления**, посылая сигналы и получая данные

Зачем View Model нужен? — Чтобы сделать View и Model независимыми. Нельзя выкинуть этот компонент, так как нельзя сделать View и Model независимыми и при этом не свазанными напрямую.

В чем преимущества MVVM:
1) Логика и интерфейс программы независимы, что избавляет от спагетти-кода
2) Читаемость и тестируемость
3) Гибкость и масштабируемость
4) Поддерживаемость программы

В чем недостатки:
1) Необходимость использования сторонних библиотек для обеспечения связи между компонентами
2) Увеличение времени разработки
3) Возможные потери производительности

Применять MVVM для приложения не стоит, если приложение мало и разработчик имеет мало опыта работы с паттерном.

**Методика:**
1) Разработать модель
2) Затем разработать представление (интерфейс)
3) Соединить интерфейс и модель прослойкой ViewModel

Реализация компонента View Model в фреймворках WPF, Avalonia, MAUI и других подобных происходит с использованием технологии "Binding". Все свойства ViewModel, описанные с помощью Binding доступны для View. Сообщения между View & Model в MVVM приложении обеспечиваются интерфейсом `INotifyPropertyChange` или семейством `ObservableObject`, который инкапсулирует упомянутый интерфейс.

Требования паттерна:
* Соблюдение принципа единственной ответственности
	* ***Модель*** не должна иметь понятия о том, как ее используют
	* ***Представление*** не должно иметь понятия о логике приложения
    	* Изменения типов UI-элементов при разработке не должны влиять на логику
* Если в ViewModel есть ссылка на System.Windows, то скорее всего разработчик что-то делает не так.

## Общий алгоритм построения MVVM приложения

Приложение для суммирования 2х чисел и получение результата

### Шаг 1

Создаем логику

```cs
static class MathFuncs
{
	public static int GetSumOf(int a, int b) => a + b;
}
```

### Шаг 2

Создаем представление

```xml
<Window ....
xmlns:local "clr-namespace: MyNamespace">
<!-- Это пространство имен с нашей VM -->
<Window.DataContext>
  <!-- Создаем новый VM и соединяем его со View -->
  <local:MainVM/>
</Window.DataContext>
  <StackPanel>
  <!--Binding, собственно, соединяет текстовое поле со свойством
  в VM -->
  <!--UpdateSourceTrigger, в данном случае, выполняет передачу
  значения в VM в момент ввода -->
		<TextBox Width="30"
			Text="{Binding Number1, UpdateSourceTrigger=PropertyChanged}">
		<TextBox Width="30"
		Text="{Binding Number2, UpdateSourceTrigger=PropertyChanged}">
<!--Mode=OneWay необходим для призязки свойства только для чтения-->
		<TextBox Width="30" Text="{Binding Number3, Mode=OneWay}"
		IsReadOnly="True">
	</StackPanel>
```

### Шаг 3

Реализуем VM. Чтобы VM автоматически обновляла View и Model, требуется реализовать интерфейс INotifyPropertyChange. Именно посредством него View получает уведомления, что во VM что-то изменилось и требуется обновить данные.

```cs
public class MainVM : INotifyPropertyChange
{
	public event PropertyChangedEventHandler PropertyChanged;
	protected virtual void OnPropertyChanged(string propertyName)
	{
		PropertyChanged?.Invoke(this,
		new PropertyChangedEventArgs(propertyName));
	}
}
```

Теперь снабдим VM тремя необходимыми свойствами. (Требования для установления связи VM и View такое, что это должны быть открытые свойства)

```cs
private int _number1;
public int Number1 {
	get => _number1;
	set
	{
		_number1 = value;
		// уведомление View о том, что изменилась сумма
		OnPropertyChanged("Number3");
	}
}

private int _number2;
public int Number2
{
	get => _number2;
	set
	{
		_number1 = value;
		OnPropertyChanged("Number3");
	}
}

public int Number3 { get; } => MathFuncs.GetSumOf(Number1, Number2);
```

#Architecture #Patterns #Patterns/MVVM #Desktop #Desktop/WPF #Desktop/Avalonia